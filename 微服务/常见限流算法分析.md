## 限流的基本概念，限流的时间区间，限流的次数，例如10秒中内请求限制在100个

- 限流的维度区分
    - 按照限流算法区分，有计数器限流，时间窗口限流，漏桶限流，令牌桶限流
    - 按照限流的对象区分，有单体应用的限流，有分布式环境下的限流(在集群的统一入口限流)

- **[计数器限流]()**
  - 算法解释
    ```
    限流算法中最简单的一种，用一个计数器来存储请求次数，纪录一个开始时间，每次请求判断计数器，
    并且判断当前时间是否小于开始时间+限流时间区间，小于说明在时间区间内，判断请求次数，
    如果数量小于指定的次数，则计数器加一，否则丢弃请求。如果大于时间区间，则进入下一个限流的区间，
    讲当前时间置位开始时间，请求次数归零
    ```
  - 算法代码
      ```
      /**
      算法的思想--  
      判断当前时间减去初始时间是否小于限流的时间区间，是的话判断当前时间已经计数的请求数量
      小于则通过请求。大于时间区间则重置限流的开始时间，计数器清零
        */
      public class CounterLimiter { 
          //初始时间
          private static long startTime = System.currentTimeMillis();
          
          private static final int interval = 10 * 1000;  //时间窗口限制 10S
          
          private static int limit = 100;  //限制通过请求
          
          private AtomicInteger requestCount = new AtomicInteger(0);  //请求计数
      
          //获取限流
          public boolean tryAcquire() {
              long now = System.currentTimeMillis();
              //在时间窗口内
              if (now < startTime + interval) {
                  //判断是否超过最大请求
                  if (requestCount.get() < limit) {
                      requestCount.incrementAndGet();
                      return true;
                  }
                  return false;
              } else {
                  //超时重置
                  requestCount = ZERO;
                  startTime = now;
                  return true;
              }
          }
      }
      ```
  - **[缺点是限流不够平滑，容易出现2倍的限制流量，出现突刺现象，实际运用不多]()**
    ```
    10秒内限流50次，在9秒多请求50次，在10.0几秒的时候请求50次，相当于一秒内请求100次。
    达到了限制50次的2倍，相当于限流无效。
    ```
    - 为了防止峰值双倍流量的突刺效应，可以将一个大的限流区间分成多个窗口，**[变成滑动窗口限流]()**
    - **[滑动窗口限流]()**
    ```
    那么滑动窗口怎么解决刚才的临界问题的呢？我们可以看上图，0:59到达的100个请求会落在灰色的格子中，
    而1:00到达的请求会落在橘黄色的格 子中。当时间到达1:00时，我们的窗口会往右移动一格，
    那么此时时间窗口内的总请求数量一共是200个，超过了限定的100个，所以此时能够检测出来触 发了限流
    ```
    ![2pc](https://github.com/caesar-empereur/read-book/blob/master/photo/distri/滑动窗口限流.png)

- **[漏桶限流]()**
    - 算法解释
        - 漏桶限流的思想是请求来的时候如果桶未满，就放到桶里面，桶满了，就丢弃请求
        - 桶的另一端用固定速度从桶里面取出请求处理
        - 流入的速度是不限制的，但是因为流出限制速度，所以起到限流的作用
        - 因此漏桶的关键是桶的消费端用固定的速度在消费请求，**[控制的是流出端的速度]()**
        - 漏桶算法不允许突发的大流量
    - 代码实现思路
        - 桶可以用一个队列来表示，请求进来了满足条件就放到队列里面
        - 对于桶的出口端，使用跟计数器限流一样的思路，相当于在出口段按照每秒多少个请求的的速度限制流量
        - 这个跟计数器限流的区别是漏桶限流在上端加上了一个限制当前总数的容器，先能添加到桶里面才能在出口端竞争
- **[令牌桶限流]()**
    - 算法解释
        - 令牌桶的思想是一个固定容量的桶，起一个线程以固定的速度向桶里面存放令牌
        - 请求进来的时候去桶里面取令牌，能取到令牌则处理请求，取不到令牌则等待或者丢弃请求
        - 令牌桶的关键是控制产生令牌的速度，**[控制的是桶的流入端的速度]()**
        - 令牌桶算法可以应对一定程度的突发流量
    - 代码实现思路
        - 同样用一个队列来表示桶，初始化桶的容量，起一个线程固定速度向桶生产令牌
        - 请求进来从桶里面获取令牌，能拿到执行请求，拿不到则等待或者丢弃请求
    - 代码实现
      ```
      public class TokenLimiter {
        private static final LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();
        private TimeUnit timeUnit;
        private Integer limitPeriod;
        private Integer limitCount;
        public TokenLimiter(TimeUnit timeUnit, Integer limitPeriod, Integer limitCount) {
            //todo 常见的构造方法的实例化
            this.init();
            this.start();
        }
        public boolean tryAccquire() {
           return queue.poll() == null ? false : true;
        }
      
        public void init() {
            for (int i=0; i<50; i++) {
               this.addToken();
            }
        }
      
        public void addToken() {
           queue.offer(1);
        }
        public void start() {
            Executors.newScheduledThreadPool(1).scheduledAtFixRate(10ms, ()->addToken(),  period, timeUnit)
        }
        
      }
      ```
