- **[feign 的远程调用资源隔离模式]()**
    - feign 的远程调用有2种，包括 **[线程隔离]()**，**[信号量隔离]()**
    - 线程隔离就是新建异步线程，信号量隔离就是使用当前线程远程调用
    - feign 默认的就是线程隔离模式
    - feign 的线程隔离还体现在不同的 FeignClient 注解的调用使用的线程池不一样
    - 一般是指不同的feign服务, 相同的feign服务里面不同的接口，使用的线程池也是一样的，只跟服务名有关
      ```
      2021-03-17 16:37:34.125  [ce-provider-b-2] com.feign.FeignFliterConfig  : ---feign 调用前拦截，当前线程 hystrix-service-provider-b-2
      2021-03-17 16:37:37.378  [ce-provider-a-3] com.feign.FeignFliterConfig  : ---feign 调用前拦截，当前线程 hystrix-service-provider-a-3
      ```
- **[feign 的断路器hystrix开启后，异步线程调用导致 ThreadLocal 丢失问题]()**
    - 描述
        ```
        feign 的 fallback 断路器要生效的话, 必须开启配置项 hystrix.feign.enable=true。
        但是该配置开启后远程调用的时候会启动新的异步线程，导致 ThreadLocal 无法传递
        ```
    - 解决方法 1 (**[修改隔离模式为信号量]()**)
      - 开启 hystrix.shareSecurityContext=true 配置，开启线程共享上下文，会使用信号量隔离模式
      - 注册一个配置为信号量隔离模式的bean, 并且 FeignClient 指定 configuration=该bean，也会使用信号量隔离模式
    - 解决方法 2 (**[使用线程隔离方式，对子线程调用封装, 传递变量]()**)
      - 使用默认的线程隔离模式，对子线程调用进行封装，在2个线程中实现传递上下文信息的逻辑
    - 解决方法 2 (**[使用线程隔离方式，使用继承的 ThreadLocal]()**)
      - 使用 InheritableThreadLocal 传递父线程的变量到子线程
- **[feign 超时重试机制不同的实现]()**
    - 重试的不同机制

          ```
          spring.cloud.loadbalancer.ribbon.enabled=false 配置不适用ribbon的客户端
          feign.hystrix.enabled=false 时候，feign 的timeout配置才会起作用
          ```
        - 该配置项开启之后，执行重试的代码是 RetryTemplate.doExecute， LoadBalancerCommond.submit()
        - 该配置项关闭之后，执行重试的代码是 FeignBlockingLoadBalancerClient.execute()
        - 总的调用时间 = 配置的超时时间 * 重试次数, 试次数是包括第一次调用的
        - ribbon 现在处于维护模式，负载均衡是用新的 springcloud-loadbalancer
        - feign.hystrix.enable=true 的时候， feign 会将调用的所有方法加上断路器封装
    - FeignBlockingLoadBalancerClient 调用跟重试的实现逻辑
        - 根据配置的 Retryer 类，生成对应的bean信息
        - 根据注册发现机制，从注册中心获取到服务列表，并且生成服务均衡客户端的map信息(工厂类)
        - 根据serviceId 获取到对应的负载均衡客户端，执行 choose 方法
        - choose 方法执行的逻辑是计算下标，对实例list.size()取模，得到对应的实例返回
        - 将得到的实例的Ip，端口替换掉URL中的服务名，执行http调用
        - 每次超时异常统计次数，选中下一个实例进行重试，超出指定次数抛异常

- feign 调用的超时，事务注解的超时，springboot 接口的超时关系
    - springboot 2.2以上版本默认是没有超时机制的,经过测试，接口线程 sleep 3分钟也不会出现超时
    - 超时机制的实现有 2 种，一种是客户端的超时设置，一种是服务端的超时设置
    - 服务端的超时机制需要依赖事务注解的超时来实现
    - 事务的注解超时时间 需要大于 feign的超时时间 * 总共重试次数，否则会出现feign重试还没执行完就被事务超时异常了
    ```
    A-->B-->C 的链路中，如果A到B的超时时间比 B 接口自身的超时时间短
    则会出现 A 等待时间到了之后抛出超时异常，B服务是感知不到A的超时的，B自身的接口还在等待，最后B的事务完成了
    但是A的事务没有完成，出现回滚，导致2个服务的事务出现不一致了
    ```

- 事务注解的超时时间的不同分析
    - 当执行事务的线程是在执行数据库操作，数据库阻塞了，线程还是在运行的(runable)，则超时时间是按照事务配置的
    - 当执行事务的线程是某种条件进入 sleep 状态，则超时时间要等到线程恢复，但是也会抛超时异常
    ```
    举个例子，超时配置3秒，当执行数据库阻塞的时候，3秒后线程抛超时异常终止，
    当执行线程由于某种条件进入 sleep状态，sleep 5秒，则会在5秒后恢复并且抛出超时异常，
    这是因为事务的超时的计时也是在事务的线程，线程sleep，没法进入计时，只能等到恢复运行后，
    计算时间发现已经超时了，才会抛异常终止
    ```

- hystrix 的熔断策略
    ```
    熔断策略指的是，在一个远程调用中出现异常的时候，如果不及时对异常进行处理就会影响到系统的正常运行，
    在多层级的服务调用中，一个节点的异常问题可能还会导致调用链路的雪崩产生更严重的影响
    因此需要有一个机制能够发现阻断这种异常，并且对异常进行熔断或者对某个服务降级。
  
    为什么要有熔断
    在没有熔断降级的情况下，上游服务调用下游服务，下游服务出现严重延迟，上游服务继续有更多请求进来调用，
    http线程池的线程慢慢被消耗完，下游服务本来延迟就是有异常，或者负载很高，更多的请求进来后，压力更大
    导致系统奔溃，本来上游服务可以及时阻断的，但是最终同归于尽。因此降级就是不要给一个不健康的服务发出调用。
    当下游服务出现调用异常次数阈值后，进行阻断
    ```
    - 超时熔断
    - 信号量隔离熔断
        - 信号量隔离是tomcat的请求线程跟远程调用的线程是同一个，不会另起异步的线程
        - 指定了feign, hystrix的信号量大小的话，就会限制一定量的请求线程，线程数达到之后就会触发熔断异常，防止线程数过多
        - 因此信号量熔断的本质是规定了信号量大小，超过数量大小就会熔断
    - 线程池隔离熔断
        - 线程池隔离是针对每一个远程调用的服务名，springcloud都会创建对应的线程池，2个调用的服务名对应的线程池是隔离开的
        - 请求线程跟远程调用的线程不是同一个，当某个服务的调用出现异常时，这个服务的线程池没有线程可用也不会影响到另一个服务的线程池
        - 因此线程池熔断时规定了服务有对应的线程池，线程池满了之后触发熔断异常
