## 各种mq的对比


- 基础的特性区别

|基础的特性|rocketmq| rabbitmq|kafka|
|:------:|:------:|:-------:|:-------:|
|开发语言| java |erlang|scala|
|事务消息| 支持,是分布式的事务消息 |只是为了保证消息成功投递|只是为了保证消息成功投递|
|延时消息| 支持 |原生不支持|原生不支持|
|如何保证消息可靠性(不丢失)| 发送端同步发送,服务端slave备份,消费端主动ack,失败重新投递 |发送端开启事务消息,服务端镜像集群,消费端失败进入死信队列|发送端开启落盘回传,服务端partition备份,|
|消息保证顺序性|发送端实现QueueSlector接口 |queue本身就是天然顺序的，消费端需要保证单线程|只保证单个分区的顺序，根据消息key哈希到某个分区|
|消费失败重试|消息阶梯重新投放 |死信队列|不支持，需要自己处理|
|性能|10w/s |消息堆积后性能不好,无论是否开启磁盘，数据都在内存处理|100w/s,依靠topic的分区,消息写入分布到不同的机器上|
|消息堆积|支持|消息堆积后性能不好，很容易挂掉|支持|
|部分特性|支持分布式事务消息,消息的tag相当于子队列的功能|rabbitmq的交换器比较灵活，还有 vhost 隔离|kafka 的分区级别的副本，分区是为了性能，副本是为了容错|


- 架构特性

|架构特性|rocketmq| rabbitmq|kafka|
|:------:|:------:|:-------:|:-------:|
|queue与topic| 一个topic下有多个msg-queue,每个topic分布在固定的broker |没有topic的概念|一个topic分成多个patition,分布在多个broker|
|消息副本机制| 消息存放到topic下的一个queue里面,消息所在的broker有slave节点充当副本 |镜像集群的消息跟topic会在多个节点上保存|消息存放到 topic下的某一个分区，每个分区的副本在别的broker节点上|
|集群部署机制|多主多从|普通集群模式，镜像集群模式|broker有leader, follower|
|高可用机制|通过name节点控制broker的主从切换|节点的镜像集群模式|通过zk控制broker的主从切换, partition级别的副本|
|适用的场景|金融，交易，订单, binlog 分发|数据量不大,需要队列跟topic灵活配置的|大数据，日志，离线数据处理|
|扩展性|新增broker节点加入到集群，新的broker默认只负责新增的 topic|新增broker节点加入到集群|新增broker节点加入到集群，新的broker默认只负责新增的 topic,旧topic的分区数据得手动迁移|




