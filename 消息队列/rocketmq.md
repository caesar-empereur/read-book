- **[JMS 模型]()**
    - **[点对点]()**
        - 点对点模式包括，队列，发送者，接收者，每个消息都会发送到指定队列，只能被一个消费者消费
        - 发送与接收没有依赖关系，消息没有消费也不会影响发送
        - 消息消费成功后必须做出应答确认
        - 如果希望每一条消息都能被对应的消费者确保处理，应该采用点对点模式
    - **[发布订阅（广播模式）]()**
        - 发布订阅模式包括 主题，发布者，订阅者，主题可以有多个订阅，也就是一个消息可以被多个订阅者消费
        - 如果希望消息被多个消费者消费，应该采用广播模式
        
- **[为什么要使用消息队列？]()**
    - 解耦
    ```
    假设这么一个场景
    一个电商的订单支付了，需要后续多个操作，给商家，买家发消息，增加商品活跃度，
    增加商家店铺活跃度，在强耦合的情况下，需要在代码里面调用这么多个服务。
    有一个出现调用异常了，整个事务操作要不要回滚？服务调用超时了怎么办？要不要重试？
    后续的有增加其他操作的话，是不是要修改订单支付后的那些代码？
    ```
    ```
    如果使用MQ的话，订单支付后只需要发一条MQ消息，采用发布订阅(广播模式)，对应的服务模块
    消费这一条消息即可，消费时需要处理好消息重复消费，顺序性，消息可靠消费等几个问题。
    后续有其他服务需要相应变动的话，按照这个模式去消费消息就可以了
    ```
    - 异步
    ```
    同样是上面订单支付的场景，没用MQ的时候，正常情况下一个个的去调用对应的服务，相应的总的耗时
    就多了(用多线程的线程池执行)，最多是所有服务耗时的综合，最少是最慢的那个服务的耗时
    
    如果是MQ的话，只需要发一条消息，时间几乎可以忽略的
    ```
    - 削峰

- **[rocketmq架构]()**
![rocketmq](https://github.com/caesar-empereur/read-book/blob/master/photo/mq/rocketmq.png)

    - NameServer
        - 可以理解为是消息队列的协调者，Broker向它注册路由信息，同时Client向其获取路由信息
        - NameServer本身是没有状态的，并且多个NameServer直接并没有通信，可以横向扩展多台，Broker会和每一台NameServer建立长连接
    - Broker
        - Broker是RocketMQ的核心，提供了消息的接收，存储，拉取等功能，一般都需要保证Broker的高可用，所以会配置Broker Slave
    - Producer
        - 消息队列的生产者，需要与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立连接
    - Consumer
        - 消息队列的消费者，同样与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master，Slave建立连接

- 消息发送接收
    - 消息的发送需要指定 topic，消息的消费需要指定topic消费
- RocketMQ中的Topic和JMS的queue有什么区别？
    - queue就是来源于数据结构的FIFO队列。而Topic是个抽象的概念，每个Topic底层对应N个queue，而数据也真实存在queue上的
- RocketMQ Broker中的消息被消费后会立即删除吗？
    - 不会，每条消息都会持久化到CommitLog中
- 消费消息是push还是pull？
    - RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是长轮询机制
- 为什么要主动拉取消息而不使用事件监听方式？
    - 事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送
    - 如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多
    - 同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈
- RocketMQ如何做负载均衡？
    - 通过Topic在多Broker中分布式存储实现。
- **[如何保证消息的顺序消费？]()**
    - 首先说明为什么会出现乱序？
    ```
    往一个队列发送 A B C 3条消息，正常顺序是 A B C，但是消费端启动了多线程消费(或者是多个消费者)，
    这样消费者2先消费完消息 B，就导致了顺序错乱
    ```
    - 首先队列是典型的FIFO 的数据结构，消息的存储就是天然顺序，单个队列是可以保证有序的
    - 多个queue同时消费是无法绝对保证消息的有序性的，一个队列的消费端是多线程消费也是无法保证顺序的
    - 消息发送的时候是可以指定某个主题下的队列的，有个接口MessageQueueSelector，可以重写里面的逻辑实现
    ```
    例如订单消息其实是有一个订单号或者订单ID的，有这个订单号的消息有多条，分别是下单，支付，出库，发货，收货
    这样的顺序，在发消息的时候可以降订单号做哈希之类的处理，然后实现 QueueSelector 接口，将该订单号的消息永远
    都只发送到一个队列里面
    ```
- **[RocketMQ 的延时消息是如何实现的？]()**
    - 延时消息的使用
        - 开源RocketMQ支持延迟消息，默认支持18个level的延迟消息(1s 5s 10s 30s 1m 2m 3m 4m.... 1h 2h)
        - msg.setDelayTimeLevel(2);
        - Broker在启动时，内部会创建一个内部主题：SCHEDULE_TOPIC_XXXX，根据延迟18个level对应了18个队列
        - 延时消息不支持秒级精度，是为了避免在broker对消息进行排序，造成性能影响
    - 延时消息内部实现机制
        - 消息进来在CommitLog中判断是延时消息会修改消息Topic名称和队列信息为延时topic和延时队列
        - CommitLog中转发消息到延迟主题的CosumeQueue中
        - 延迟服务消费SCHEDULE_TOPIC_XXXX消息，并且启动定时计算
        - 延时服务判断到时间一到就将信息重新存储到CommitLog中
        - CommitLog中将消息投递到目标Topic，队列中
        - 消费者消费目标topic中的数据
    - ![rocketmq事务消息](https://github.com/caesar-empereur/read-book/blob/master/photo/mq/rocketmq延时消息.png)

    
- 如何保证消息不被重复消费？
    - 消息为什么会出现重复？
    ```
    只要是消息队列就有可能会重复，消息重复不只是消息队列的问题，应用的消费端同样也要做好处理的
    
    有这样一个场景，消费端消费消息，已经消费完了，但是做出应答回复的时候应用挂掉了，服务器以为消息没消费成功。
    下次应用重启了，还是消费到上一条消息，就出现重复消费了
    ```
    - 消息队列本身是有机制保证不重复的
        - kafaka里面，每一条消息是有一个叫偏移量的东西的，代表消息的序号
        - 每消费一条消息，就会应答这个消息的偏移量，服务器就知道下一次的消息投递到消费端需要从这个偏移量的下一个
        - 这个机制靠的是消费端的应答机制，但是应用应答的时候挂掉了，这个机制就没法保证了
    - 消息重复消费不可怕，重要的是如何保证消费端的幂等
        - 幂等是指一条消息就算多次消费也不会出现问题
        - 消费端的幂等一般是用数据库唯一键，或者每次消费前先查一下数据库再消费

- **[RocketMQ如何保证消息不丢失]()**
    - **[发送端]()**：采用同步发送，消息投递成功才返回，设置失败重试次数，有时候失败是因为某个Broker挂掉，重试会发到其他Broker
    - **[Broker]()**： 的消息刷盘改为同步刷盘，默认是异步的，采用高可用集群部署，主从模式
    - **[消费端]()**：对消息消费成功后进行应答确认
- **[消息服务器如何保证高可用？]()**
    - RabbitMq
        - 镜像集群模式
        - 部署多个节点的消息服务器，每一个队列的数据都会存在于所有的节点上
        - 好处是真正的高可用，一个节点挂掉了也不会影响
        - 坏处是性能开销太大，每个消息要同步到所有节点上，扩展性较差，新加进来的节点也要存放之前的队列
    - 
- **[rocketMQ的消息堆积如何处理？]()** (生产上积压了几百万条消息)
    - 首先明确消息堆积的原因肯定是消费速度跟不上生产，查看消费速度是否正常，正常的话可能是消费端实例不够，启动多个实例
    - 如果消费速度根据业务判断是不正常的，可能是消费端出问题了，要么是数据库负载高，或者数据原因导致的消费慢
    - **[消费端除问题部署多个消费端的实例时解决不了问题了]()**，所以需要转移积压的消息
        - 1 准备临时topic(队列数量是堆积的几倍)，队列分布到多个Broker
        - 2 上线一个消费端，把消息从原来topic搬到临时topic，不做业务逻辑
        - 3 排查消费端消费慢的问题，改bug
        - 4 上线多台消费端，消费临时topic 的消息
        - 改方案的解决目的是临时把消息的堆积转移到其他Broker,不然一个上线多个有问题的消费端本身就是问题
    - **[消息积压的问题排查不一定是扩容]()**
        - rocketmq 也是java程序，第一步应该用命令排查耗时比较长的线程
        - mq 的客户端是集成在 springboot 应用里面的，因此消费端的进程就是 springboot 的进程
        - top -H 命令只能找出 cpu 消耗高的线程，消费者线程卡住了，占用的 cpu 应该不会很高的
        - 可以用 jstack 命令输出线程栈到一个文件，多输出几个文件，对比找出线程状态一直为 runnable 的
        - 这些线程就是消费卡住的线程，查看代码，定位到类跟方法
        - 用 arthas trace 命令找出耗时较长的代码，一般是数据库，网络请求，磁盘io之类的操作
        - 在排查完一个消费端的慢的问题之后，消费扩容才有意义，贸然扩容消费是无法解决问题
        - 再者，扩容不一定是扩容消费端应用，如果是数据库瓶颈的话，应该先扩容数据库
        ```
        消费端速度慢不一定就是问题，因为消息队列本身除了异步，还有将峰值流量转换为平缓流量的功能，
        在峰值流量期间，本身是可以支持消费比生产慢的，只要消费端数据库的 tps 是正常的
        ```
- rocketMq事务消息
    - ![rocketmq事务消息](https://github.com/caesar-empereur/read-book/blob/master/photo/mq/rocketmq事务消息.png)
