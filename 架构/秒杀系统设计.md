## 电商秒杀系统架构

- **[前端](#)**
    - CDN 资源静态化
    - 秒杀连接加密动态话，只能从后端获取，防止连接提前暴露
    - 前端限流，按钮不能重复点击

- 代理层**[限流](#)**
    - **[限流](#)**
        - 对单个IP的请求限流，最多只能请求一次
            - 每个IP都维护一个dict的内存变量，每次校验次数大于1的，统统返回
        - 单个IP限流之后，还要对总的放过去的请求限流
            - 1万人抢100个商品，只需要放1000个人进来就可以了，其余的9000人拦截掉
            - nginx lua 里面做个计数器，请求一次加1，到达1000之后全部返回，不进入后端
        - 经过以上限流之后，，进入后端的并发请求量就大大降低了80%了，反正秒杀对用户来说是黑盒子
    - **[恶意请求识别](#)**
        - 接入风控系统，识别机器人的操作
        - 风控的拦截应该是拦截掉的不能计入限流的总请求数量
    - **[后端逻辑前置](#)**
        -在代理层完成对redis库存的检查扣减，成功的保存对一个list中，这种方式更简单粗暴，不访问后端了
- 后端
    - **[热点商品发现](#)**
        - 一些访问量大的商品，可能要做缓存处理，但是问题是秒杀前怎么知道哪些是热点商品？
        - 构建一个异步的商品发现系统，收集统计交易链路上商品的成交次数，例如nginx，缓存，rpc
        - 或者是秒杀提前报名，卖家提前通知系统哪些商品需要进行秒杀，就可以做对应的处理
    - **[应用隔离](#)**
        - 不仅仅是应用，还有域名都与平时的系统隔离分开部署，出现问题也不会影响到其他的
        - 应用隔离的原因是 tomcat 的线程数，连接数是有限制的，瞬时的高并发请求会影响到其他的功能
        - tomcat 的最大线程数(几百)，连接数是有限制的，因此可能要多部署多个应用组成负载均衡
    - **[数据库库存设计](#)**
        - 什么时候扣减库存？
            - 下单马上扣减库存
                - 最简单精确的方式，但是可能会出现某些人将全部库存下单又不支付
                - 针对恶意下单多个库存的，需要做出单个买家只能购买多少个的限制
            - 支付扣减库存
                - 会出现100个商品200个人下单成功，但是支付的时候有100个人支付失败，这是很糟糕的体验
            - 下单扣减库存加上时间限制
                - 下单成功时扣减库存，规定30分钟内没支付的话库存释放
        - **[扣减库存的sql语句](#)**
            - 更新库存时带上条件
            ```
            UPDATE t_sku SET count = CASE WHEN count >= 0 THEN
            count-1 ELSE count END where id=***
            ```
            ```
            UPDATE t_sku SET count = count-1 where id=*** and count >= 0
            ```
            - 采用乐观锁来扣减库存 (在库存表加上版本号作为乐观锁)
                - 先查出id=** 的库存记录，然后做更新, 更新sql跟上面差不多，但是加上 where version=上一步select出来的
                - 如果版本被修改过，则更新失败
                - 这种先select，再update的操作涉及到数据库的隔离级别，默认是可重复读
        - **[高并发扣减库存的资源消耗问题](#)**
            - 秒杀时对库存表的一行记录做高并发的更新，有大量线程来竞争锁
            - 导致数据库实例的TPS下降，甚至是秒杀请求占用了大量的数据库连接
            - 最终结果就是一个商品的秒杀严重影响了其他99%的商品的售卖
            - 解决方式是把热门商品的秒杀放到一个单独的库中，做数据库的隔离
        - 秒杀商品的并发锁的问题
            - 有大量线程对某行记录的锁竞争，会严重消耗数据库的性能，因此需要考虑将并发变成排队处理的方式
            - 淘宝的mysql开发团队开发过数据库的补丁，可以针对一行记录做到并发的排队
            
    - **[读写降级](#)**
        - 数据库是比较薄弱的环节，因此对库存的读写改为缓存
    - **[redis 库存设计(超卖问题)](#)**
        - 队列，在redis的list中lpush 100个商品，减库存的时候 lpop出来，能pop出数据的发一条MQ消息
        - 将 (检查库存，扣减库存，返回) 这3个操作用Lua脚本包住，在分布式环境下也是原子操作，能返回1的发MQ消息
    - mysql 扣减库存设计
    - **[库存扣减成功的订单处理](#)**
        - 上面的库存扣减成功的发MQ消息，消息包含用户id，因此把并发的对数据库的操纵变成串行的，降低数据库压力
