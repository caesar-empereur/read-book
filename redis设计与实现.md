## 9章 服务器中的数据库

- 切换数据库
    * 客户端 select 命令切换数据库
    * 客户端 redisClient 的 db 属性记录当前指向的数据库，切换就是修改 db 的指向
    
- 数据库键空间
    * 1  redis 服务器中的每个数据库都有一个 redisDb 结构体的 **[dict字典](#dict字典)** 保存所有的 **[key-value](#key-value)** ,称为键空间, 结构如下

        键         | 键的数据结构       |
        -----------|-------------------|
        "list"     | 列表               |
        "hash"     | 哈希表             |
        "string"   | 字符串             |
    * 2 对 key value 的操作都是修改 dict 字典
    * 3 设置 key 的过期时间
        * redisDb 结构体的 **[expire过期字典](#expire过期字典)** 保存了 key 对应的过期时间，结构如下
        
            键             | 过期时间          |
            ---------------|-------------------|
            "name" 键的指针 | 10秒             |
            "age"  键的指针 | 20秒             |
            "phone"键的指针 | 30秒             |
            
        * 修改删除过期时间都是对 expire 字典修改
        * 判断 key 是否过期
            * 每次获取 key 判断是否在 过期字典中，没有就直接返回
            * 有的话拿出过期时间与当前时间对比，过期则返回空，是否删除要根据策略

- 过期删除策略

    删除策略     | 键的数据结构       | 键的数据结构   |
    ------------|--------------------|-------------------|
    定时删除     | 设置键的过期时间时，创建一个定时器，时间一到就删除                |  内存友好，消耗 CPU  |
    **惰性删除** | 每次获取key的时候再去检查是否过期，是就删除返回空，没就返回 value  | 占用内存，不消耗 CPU |
    **定期删除** | 服务器每隔一点时间检查，删除过期键                                |  折中方案           |

- 过期删除对 RDB, AOF 文件的影响
    
     顺序    | 操作       |
     -----------|-------------------|
     1    | SAVE 命令生成 RDB 文件时，过期的键被检查到，不会写到 RDB 文件中   |
     2     | redis 以 主 模式载入 RDB 时，过期的键不会载入 |
     3   | redis 以 从 模式载入 RDB 时，过期键也会载入，等到主删除过期键时，会发送同步命令删除从的 |
     4   | redis 以 AOF 模式运行时，过期键还没删除的也会写入 AOF, 只有过期时才向 AOF 文件追加 删除命令 |
     5   | 主 发现并删除过期键时，会同步删除命令到从 |

## 10章 RDB持久化
   * 创建 RDB 文件
      * SAVE 命令，服务器会一直阻塞，期间无法接收命令
      * BGSAVE 命令，新建一个进程，不会阻塞
   * 载入 RDB 文件
      * 开启了 AOF 时，会载入 AOF 文件
      * 没开启 AOF 时，会载入 RDB 文件
      * 载入RDB期间，服务器会阻塞
   * **[RDB文件包含了全部的键值对数据](#RDB文件包含了全部的键值对数据)**


## 11章 AOF持久化

   * AOF文件保存的是一条条的 **[写命令](#写命令)**，服务器每执行一条写命令，都会追加写入到 AOF 文件里
   
   * AOF 文件的载入还原
      * 服务器启动时，**读取AOF文件中的所有命令拿到数据库执行**
      * 命令是通过创建一个不带网络连接的 **[伪客户端](#伪客户端)** 执行的
      
   * AOF 重写
   
      顺序    | 操作       |
     -----------|-------------------|
     1    | 对于一个列表类型的键的 **多次写操作记录多条写命令**，AOF文件体积会很大，存储载入都耗资源  |
     2     | 对于一个列表类型的键，只需要一条写命令记录全部数据 |
     3   | redis 以 从 模式载入 RDB 时，过期键也会载入，等到主删除过期键时，会发送同步命令删除从的 |
     4   | 后台获取键对应的数据后生成一条命令，写入2个缓冲区，后续键的数据有变化时 |
     5   | 每一条写命令，后台会写入到 AOF **[缓冲区](#缓冲区)** 与 **[AOF重写缓冲区](#AOF重写缓冲区)** |
     6   | 两个缓冲区的数据都会写入到对应的文件，重写结束时，重写缓冲区文件替换掉 缓冲区文件 |

## 15章 复制

>> Redis的 **[复制](#复制)** 功能分为 **[同步sync](#同步sync)** 和 **[命令传播](#命令传播)** 两个操作

>> **127.0.0.1:6378 > SLAVEOF 127.0.0.1:6379** ==> 6378 复制 6379

* **[同步](#同步)** 操作用于将从的数据库状态更新至主当前所处的数据库状态
    
    顺序    | 操作       |
     -----------|-------------------|
     1    | 从向主发送SYNC命令   |
     2     | 收到SYNC命令的主执行BGSAVE命令，在后台生成一个RDB文件 |
     3   | 将BGSAVE命令生成的RDB文件发送给从 |
     4   | 从将自己的数据库状态更新至主执行BGSAVE命令时的数据库状态。 |


- **[命令传播](#命令传播)** 操作则用于同步操作后致主从的数据库状态出现不一致时，让主从的数据库重新回到一致状态。

    * 1 主数据变化后，会将自己执行的写命令发送给从服务器执行
    * 2 当从执行了相同的写命令之后，主从将再次回到一致状态
    * 在命令传播阶段，从会以每秒一次的频率，向主发送命令

- **[旧版同步操作缺陷](#旧版同步操作缺陷)**

    * 1 主从同步过一次后断线再进行同步，会执行上一步的同步的内容(没有必要，需要的是需要同步断线后主变动的数据)
    * 2 sync 操作耗时耗资源，需要主 执行 BGSAVE生成RDB文件，传输给从，消耗CPU内存磁盘资源
    * 3 从 接受到RDB文件后载入RDB文件，这时服务器会阻塞，无法处理客户端请求


> Redis从2.8版本开始，使用 **[PSYNC](#PSYNC)** 命令代替SYNC命令来执行复制时的同步操作

- **[PSYNC](#PSYNC)** 命令具有 **[完整重同步](#完整重同步)** 和 **[部分重同步](#部分重同步)** 两种模式

    * 完整重同步用于处理初次复制情况：完整重同步和SYNC命令的执行一样，都是通过让主创建并发送RDB文件
    * 部分重同步则用于处理断线后重复制情况：主从断开后, 主将断开期间主执行的写命令发送给从，从只要接收并执行这些写命令
    * **[部分重同步的原理](#部分重同步的原理)**
        * 主和从会分别维护一个复制偏移量
        * 主每次向从传播N个字节的数据，就将自己的偏移量的值加上N
        * 从每次收到主传播来的N个字节的数据时，就将自己的偏移量的值加上N
        
           顺序    | 操作       |
        -----------|-------------------|
        1    | 主和从会分别维护一个复制偏移量   |
        2     | 主每次向从传播N个字节的数据，就将自己的偏移量的值加上N |
        3   | 从每次收到主传播来的N个字节的数据时，就将自己的偏移量的值加上N |
- PSYNC 命令的实现
    * PSYNC 从服务器 命令的调用方法有两种
        * 如果从以前没有复制过任何主, 从在开始一次新的复制时将向主发送PSYNC -1
        * 如果从已经复制过某个主，那么从在开始新的复制时将向主发送PSYNC ＜runid＞ ＜offset＞
    * PSYNC 主服务器返回3种回复
        * 如果主返回+FULLRESYNC runid offset，那么表示主将与从执行完整重同步操作
        * 如果主返回+CONTINUE回复，那么表示主将与从执行部分重同步操作
        * 如果主返回-ERR回复，那么表示主的版本低于Redis 2.8
        
## 16章 sentinel 哨兵模式
- 哨兵模式

    * 哨兵是 redis 的高可用解决方案
    * 一个或多个 哨兵实例组成哨兵系统，监控多个主从
    * 发现主服务器下线时，将某个从升级为主
    * sentinel 向多个从发送 复制 指令，故障转移完毕
    * 之前掉线的主恢复上线时，设置为从
    
- 哨兵模式的工作流程

    * 1 启动初始化 sentinel
        * 1.1 初始化服务器，sentinel 是一个运行在 **[特殊环境](#特殊环境)** 下的 redis 服务
        * 1.2 将 redis 服务变成 sentinel 服务，sentinel 模式下，无法执行 set get 命令
        * 1.3 初始化 sentinel 状态下的 master 属性，记录了主服务器地址
        * 1.4 连接到 主，成为主的客户端，用来发送命令
        
           顺序    | 操作       |
        -----------|-------------------|
        1    | 初始化服务器，sentinel 是一个运行在 **[特殊环境](#特殊环境)** 下的 redis 服务   |
        2     | 将 redis 服务变成 sentinel 服务，sentinel 模式下，无法执行 set get 命令 |
        3   | 初始化 sentinel 状态下的 master 属性，记录了主服务器地址 |
        4   | 连接到 主，成为主的客户端，用来发送命令 |
    * 2 获取 主服 信息
        * 2.1 定时通过发送 INFO 命令到主来获取主服务器的信息
        * 2.2 主返回的信息包括主自己的信息，还有主下面的从服务器的地址状态等信息
    * 3 sentinel 发送 ping 命令到各个 redis 服务器，规定时间内没有返回回复的判断为 **[主观下线](#主观下线)**
    * 4 sentinel 询问其他 sentinel 主观下线的 redis 服务是否也是下线，是的话就是 **[客观下线](#客观下线)**
    * 5 选举领头 sentinel
        * 5.1 每个发现客观下线的 sentinel 都会发命令要求其他 sentinel 将自己设置为 领头 sentinel
        * 5.2 **[发命令是先到先得](#发命令是先到先得)**，谁先发，谁先成为 领头
    * 6 **[故障转移](#故障转移)** (领头sentinel选举后，需要对下线的主执行故障转移)
        * 6.1 在主下的从里面，选一个变成主
        * 6.2 让旧的从复制新的主数据 (修改之前的复制目标)
        * 6.3 下线的主设置为从，上线时再去复制新的主
        
           顺序    | 操作       |
        -----------|-------------------|
        1    | 在主下的从里面，选一个变成主 |
        2     | 让旧的从复制新的主数据 (修改之前的复制目标) |
        3   | 下线的主设置为从，上线时再去复制新的主 |
        
## 17章 集群
> redis 集群可以提供相对于单机更可靠的服务

- 1 集群模式的建立
    * 1.1redis 服务启动时检查配置项 cluster-enable 是否开启
    * 1.2开启的话读取集群的地址信息，发送命令到指定服务器 CLUSTER MEET 建立连接创建集群
    * 1.3这时集群还不是上线状态

- 2 槽指派
    * 2.1 redis 集群通过 **[分片](#分片)** 来保存数据，整个集群分配了 16384 个槽用来存储数据，每个服务器可处理最多 16384
    * 2.2 **所有槽都有服务器接受处理时 集群才是上线状态**，只要有一个槽没人接收处理，就是 下线
    * 2.3 可以向集群下的节点发送命令，**指定节点处理的哪些槽** CLUSTER ADDSLOTS 0 1 2 ...5000
    * 2.4 每个节点记录自己的槽信息，**还会向其他的节点传播自己的槽信息**，节点两两互相传播

- 3 在集群中执行命令 （虽然是集群模式，但是执行命令时仍然需要指定哪个节点处理）

    * 3.1 某个节点接收到数据处理命令时，先算出 key 所属的槽是不是自己负责的，是的就处理数据
    * 3.2 不是自己负责的，找到槽对应的节点，返回客户端 **[MOVED](#MOVED)** 错误 和 **[重定向](#重定向)** 指令
    * 3.3 **集群模式下客户端不会打印这个 MOVED 错误**，而是直接重定向到指定服务器 操作数据

```
        单机模式下，判断到key所属的槽不是自己的，客户端直接打印错误
        集群节点只能使用0号数据库，单机Redis没有这一限制
```

- 4 重新分片
```
        重新分片，将某个节点下的一些槽重新分配到另一个节点，槽对应的key数据也会随着迁移
        经常出现在集群要加入新的节点时
        分片不需要集群下线
        Redis集群的重新分片操作是由Redis的集群软件redis-trib负责执行的
```
-
   
   '     | redis-trib 操作       | '   |
    ------------|:--------------------:|-------------------|
    源节点     | ---->导入哪些槽      | **[1](#1)** 目标节点  |
    源节点 **[2](#2)** | 导出哪些槽----->  | 目标节点 |
    源节点 **[3](#3)** | 迁移槽对应的键数据------>   |  目标节点           |
    源节点 | **[4](#4)** 通知整个集群 : 哪些槽被迁移到哪里   |  目标节点           |
    
- 5 复制与故障转移
    
```
    Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，而从节点则用于复制某个主节点，
    主节点下线时，代替主节点继续处理命令请求
```
-
    * 5.1 主节点下线时，主下面的多个从选出一个作为主，接管旧的主的槽数据，其他从复制新的主
    * 5.2 旧的主上线时，成为新的主的从
    * 5.3 CLUSTER REPLICATE node-id 可以实现指定某个节点复制 node-id 主节点，成为它的从
    
## 19章 事务

- 1 事务的实现
    * 1.1 **[MULTI](#MULTI)** 开始事务
    * 1.2 命令入队，**EXEC、DISCARD、WATCH、MULTI** 这4个命令会被马上执行，其他的命令会 返回 **QUEUED** 回复
    * 1.3 执行事务，EXEC 命令将队列的命令执行
    
```
WATCH命令是一个乐观锁，可以在EXEC命令执行之前，监视数据库键，并在EXEC命令执行时，
检查被监视的键是否已经被修改过，如果是的话，服务器将拒绝执行事务，
并向客户端返回代表事务执行失败的空回复
```

- 2 watch 命令的实现

    * 2.1 watch 命令的执行

         客户端A         | 客户端B         |
        ---------------- |-----------------|
        watch "name"     |                 |
        multi            |                 |
        set "name" "hehe"|                 |
        '                |set "name" "haha"|
        返回 error       |                 |

    * 2.2 watch 命令的实现
        * 2.2.1 每个redis 服务器都会保存一个 watched 字典,结构如下

             键        | 监控的客户端<链表> |
            -----------|-------------------|
            "name"     | 客户端A -> 客户端B |
            "age"      | 客户端C            |
            "phone"    | 客户端D -> 客户端E | 

        * 2.2.2 watch 字典的检查过程
            * 1 所有对键数据修改的命令，都会检查服务器上的 watched 字典
            * 2 如果修改的键在字典中有，就会修改对应客户端的 一个 DIRTY_CAS 标记为 TRUE
            * 3 客户端发送到服务器的执行命令，服务器发现 DIRTY_CAS 为 TRUE, 说明安全性被破坏，返回错误

