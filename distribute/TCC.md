- TCC是服务化的两阶段编程模型，其Try、Confirm、Cancel 3个方法均由业务编码实现
    - Try操作作为一阶段，负责资源的检查和预留
    - Confirm操作作为二阶段提交操作，执行真正的业务
    - Cancel是预留资源的取消；



- 业务实现TCC服务之后，该TCC服务将作为分布式事务的其中一个资源，参与到整个分布式事务中 
    - 事务管理器分2阶段协调TCC服务，在第一阶段调用所有TCC服务的Try方法
    - 在第二阶段执行所有TCC服务的Confirm或者Cancel方法；
![image.png](http://note.youdao.com/yws/res/7716/WEBRESOURCE1ff7ef6c6fa5d2fcb6305acfd78d55c2)

- 接入TCC 分布式事务的条件
    - 首先需要选择某种 TCC 分布式事务框架，各个服务里就会有这个 TCC 分布式事务框架在运行
    - 原本的一个接口，要改造为 3 个逻辑，Try-Confirm-Cancel：


- TCC 分布式事务框架是如何保证之前没执行完的分布式事务继续执行的
    - TCC 事务框架都是要记录一些分布式事务的活动日志的(操作记录)
    - 可以在磁盘上的日志文件里记录，也可以在数据库里记录。
    - 保存下来分布式事务运行的各个阶段和状态

- 万一某个服务的 Cancel 或者 Confirm 逻辑执行一直失败怎么办
    - TCC 事务框架会通过活动日志记录各个服务的状态


- 用户在实现TCC服务时，有以下注意事项
    - 接入TCC之后，需要考虑如何将其分成2阶段完成
        - 把资源的检查和预留放在一阶段的Try操作中进行，把真正的业务操作的执行放在二阶段的Confirm操作中进行；
![image.png](http://note.youdao.com/yws/res/7737/WEBRESOURCE62f8cae5b6434993ee20ad508169eb1c)
    - 允许空回滚
        - 事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因为丢包而导致的网络超时
        - 此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作。
        - TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行
    - 防悬挂控制
        - 调用TCC服务的Cancel操作；在此之后，拥堵在网络上的一阶段Try数据包被TCC服务收到，
        - 出现了二阶段Cancel请求比一阶段Try请求先执行的情况；
        
    - 幂等控制
        - 无论是网络数据包重传，还是异常事务的补偿执行，都会导致TCC服务的Try、Confirm或者Cancel操作被重复执行；
        - 用户在实现TCC服务时，需要考虑幂等控制，即Try、Confirm、Cancel 执行次和执行多次的业务结果是一样的
    - 业务数据可见性控制
        - TCC服务的一阶段Try操作会做资源的预留
        - 在二阶段操作执行之前，如果其他事务需要读取被预留的资源数据
        - 那么处于中间状态的业务数据该如何向用户展示，需要业务在实现时考虑清楚；
        - 通常的设计原则是“宁可不展示、少展示，也不多展示、错展示”
    - 业务数据并发访问控制
        - TCC服务的一阶段Try操作预留资源之后，在二阶段操作执行之前，预留的资源都不会被释放
        - 如果此时其他分布式事务修改这些业务资源，会出现分布式事务的并发问题；
        - 用户在实现TCC服务时，需要考虑业务数据的并发控制，尽量将逻辑锁粒度降到最低，以最大限度的提高分布式事务的并发性
