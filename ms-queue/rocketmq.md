- **[JMS 模型]()**
    - **[点对点]()**
        - 点对点模式包括，队列，发送者，接收者，每个消息都会发送到指定队列，只能被一个消费者消费
        - 发送与接收没有依赖关系，消息没有消费也不会影响发送
        - 消息消费成功后必须做出应答确认
        - 如果希望每一条消息都能被对应的消费者确保处理，应该采用点对点模式
    - **[发布订阅（广播模式）]()**
        - 发布订阅模式包括 主题，发布者，订阅者，主题可以有多个订阅，也就是一个消息可以被多个订阅者消费
        - 如果希望消息被多个消费者消费，应该采用广播模式

- **[rocketmq架构]()**
![rocketmq](https://github.com/caesar-empereur/read-book/blob/master/photo/rocketmq.png)

    - NameServer
        - 可以理解为是消息队列的协调者，Broker向它注册路由信息，同时Client向其获取路由信息
        - NameServer本身是没有状态的，并且多个NameServer直接并没有通信，可以横向扩展多台，Broker会和每一台NameServer建立长连接
    - Broker
        - Broker是RocketMQ的核心，提供了消息的接收，存储，拉取等功能，一般都需要保证Broker的高可用，所以会配置Broker Slave
    - Producer
        - 消息队列的生产者，需要与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立连接
    - Consumer
        - 消息队列的消费者，同样与NameServer建立连接，从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master，Slave建立连接

- 消息发送接收
    - 消息的发送需要指定 topic，消息的消费需要指定topic消费
- RocketMQ中的Topic和JMS的queue有什么区别？
    - queue就是来源于数据结构的FIFO队列。而Topic是个抽象的概念，每个Topic底层对应N个queue，而数据也真实存在queue上的
- RocketMQ Broker中的消息被消费后会立即删除吗？
    - 不会，每条消息都会持久化到CommitLog中
- 消费消息是push还是pull？
    - RocketMQ没有真正意义的push，都是pull，虽然有push类，但实际底层实现采用的是长轮询机制
- 为什么要主动拉取消息而不使用事件监听方式？
    - 事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送
    - 如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多
    - 同时又不能被其他consumer消费的情况。而pull的方式可以根据当前自身情况来pull，不会造成过多的压力而造成瓶颈
- RocketMQ如何做负载均衡？
    - 通过Topic在多Broker中分布式存储实现。
- **[如何让RocketMQ保证消息的顺序消费？]()**
    - 首先队列是典型的FIFO 的数据结构，消息的存储就是天然顺序，单个队列是可以保证有序的
    - 多个queue同时消费是无法绝对保证消息的有序性的，因此确保发布跟消费都只在一个队列里面
    - 消息发送的时候是可以指定某个主题下的队列的，有个接口MessageQueueSelector，可以重写里面的逻辑实现
- **[RocketMQ如何保证消息不丢失]()**
    - **[发送端]()**：采用同步发送，消息投递成功才返回，设置失败重试次数，有时候失败是因为某个Broker挂掉，重试会发到其他Broker
    - **[Broker]()**： 的消息刷盘改为同步刷盘，默认是异步的，采用高可用集群部署，主从模式
    - **[消费端]()**：对消息消费成功后进行应答确认
- **[rocketMQ的消息堆积如何处理？]()** (生产上积压了几百万条消息)
    - 首先明确消息堆积的原因肯定是消费速度跟不上生产，查看消费速度是否正常，正常的话可能是消费端实例不够，启动多个实例
    - 如果消费速度根据业务判断是不正常的，可能是消费端出问题了，要么是数据库负载高，或者数据原因导致的消费慢
    - **[消费端除问题部署多个消费端的实例时解决不了问题了]()**，所以需要转移积压的消息
        - 1 准备临时topic(队列数量是堆积的几倍)，队列分布到多个Broker
        - 2 上线一个消费端，把消息从原来topic搬到临时topic，不做业务逻辑
        - 3 排查消费端消费慢的问题，改bug
        - 4 上线多台消费端，消费临时topic 的消息
        - 改方案的解决目的是临时把消息的堆积转移到其他Broker,不然一个上线多个有问题的消费端本身就是问题
- rocketMq事务消息
    - 
