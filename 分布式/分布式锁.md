## redis 分布式锁
>> 使用同一个key，设置成功的话返回1，说明拿到锁，没有则等待，释放锁的时候把key删掉
- 操作方式
    * setnx(key1, value1);
    * del(key1)
- 分布式锁的问题
    - 1 del 的时候程序挂掉，没有del 成功，锁没有释放怎么办？
        * 答：给锁设置过期时间，防止没有释放锁
    - 2 客户端A的锁过期了，客户端B可以加锁，这时候有2个客户端持有锁，相当于锁失效了，怎么办？
        * 1 加大锁的超时时间，但不一定解决问题，因为业务逻辑执行时间是不确定的
        * 2 锁的value设置为一个UUID, 释放的时候判断是自己设置的UUID的锁再del

    - 2 因为key 都是一样的，一个客户端把另一个客户端的锁释放了，释放了不属于自己的锁，怎么办？
        - 一个线程可以释放了别人上的锁，相当于分布式锁都随时可以被别人释放掉，等于白锁
        * 答：锁的value设置为加锁进程id, 释放的时候判断value是当前进程的，只有加锁的人才可以解锁

    - 3 按照先判断锁的value再del，2步操作，不是原子性的，del 的时候自己的锁过期了，把别人的锁 del了，怎么办？
        * 答：判断自己的锁再del，整个操作用lua脚本来执行, redis 的 eval() 命令在执行lua脚本时，
          脚本会当作一个命令执行，执行完了再执行其他的
    - 4 集群环境中存放锁的服务器故障导致 **[2个客户端拥有锁的问题]()**
        ```
        集群环境中，存放锁的key的服务器挂掉，key没有转移到其他服务器上，导致原有的锁丢失，客户端发现可以加锁，
        于是产生了2个客户端同时拥有锁的过程
        ```
        - 答：采用 **[RedLock]()** 的解决方案

            - 1 在5个节点的redis集群中，使用key 和随机值的value 轮流在每台机器上获取锁
            - 2 只有在3个节点上获取到了锁，才算成功拿到锁
            - 3 拿到锁之后，计算花费的时间，把超时时间延长对应的花费时间
            - 4 规定时间(超时时间)内没拿到锁，到对应的redis节点上把key删掉(锁释放)
            - 5 锁释放的时候同样需要到对应的节点上把key删掉
        - RedLock 的具体实现

            - RedLock redLock = redissionClient.getLock() 尝试获取锁
            - redLock.tryLock(获取锁的规定时间, 失效时间, 时间单位);3
            - redLock.unlock()
    - 5 redis 分布式可重入锁
        * 获取锁失败的时候判断value是不是跟当前线程id一样，是的可以重入锁

- redisson 分布式锁原理
    - 从加锁过程，锁的互斥, 锁的续期，锁的释放机制来解释
    - 加锁
        - 加锁是一段rua脚本, 先判断key是否存在，不存在set进去，value是当前客户端id，并且设置过期时间
    - 锁的互斥
        - 另一个线程进来判断当前key存在了,value不是自己的,订阅锁的释放事件
        - 等待到最后没有锁释放通知，返回加锁失败
        - 等待中有锁释放机制，那就重新尝试加锁，成功就返回
    - 锁的续期
        - 当前线程持有锁，运行中想要延长锁的时间，需要开启 watch dog 后台线程
        - 后台线程每隔一段时间检查锁是否被当前持有，然后延长过期时间
    - 锁的释放
        - 删除锁的key
        - 发布锁释放的事件, 通知当前正在等待锁的进程
        - 关闭后台watch dog线程
