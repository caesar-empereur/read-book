## redis 分布式锁
>> 使用同一个key，设置成功的话返回1，说明拿到锁，没有则等待，释放锁的时候把key删掉
- 操作方式
    * setnx(key1, value1);
    * del(key1)
- 延伸出来的问题
    - 1 del 的时候程序挂掉，没有del 成功，锁没有释放怎么办？
        * 答：给锁设置过期时间，防止没有释放锁
    - 2 客户端A的锁过期了，客户端B可以加锁，这时候有2个客户端持有锁，相当于锁失效了，怎么办？
        * 1 加大锁的超时时间，但不一定解决问题，因为业务逻辑执行时间是不确定的
        * 2 锁的value设置为一个UUID, 释放的时候判断是自己设置的UUID的锁再del

    - 2 因为key 都是一样的，一个客户端把另一个客户端的锁释放了，释放了不属于自己的锁，怎么办？
        * 答：锁的value设置为一个UUID, 释放的时候判断是自己设置的UUID的锁再del

    - 3 按照先判断锁的value再del，2步操作，不是原子性的，del 的时候自己的锁过期了，把别人的锁 del了，怎么办？
        * 答：判断自己的锁再del，整个操作用lua脚本来执行, redis 的 eval() 命令在执行lua脚本时，
          脚本会当作一个命令执行，执行完了再执行其他的
    - 4 集群环境中存放锁的服务器故障导致 **[2个客户端拥有锁的问题]()**
        ```
        集群环境中，存放锁的key的服务器挂掉，key没有转移到其他服务器上，导致原有的锁丢失，客户端发现可以加锁，
        于是产生了2个客户端同时拥有锁的过程
        ```
        - 答：采用 **[RedLock]()** 的解决方案

            - 1 在5个节点的redis集群中，使用key 和随机值的value 轮流在每台机器上获取锁
            - 2 只有在3个节点上获取到了锁，才算成功拿到锁
            - 3 拿到锁之后，计算花费的时间，把超时时间延长对应的花费时间
            - 4 规定时间(超时时间)内没拿到锁，到对应的redis节点上把key删掉(锁释放)
            - 5 锁释放的时候同样需要到对应的节点上把key删掉
        - RedLock 的具体实现

            - RedLock redLock = redissionClient.getLock() 尝试获取锁
            - redLock.tryLock(获取锁的规定时间, 失效时间, 时间单位);3
            - redLock.unlock()
    - 5 redis 分布式可重入锁
        * 获取锁失败的时候判断value是不是跟当前线程id一样，是的可以重入锁
