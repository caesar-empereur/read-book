![2pc](https://github.com/caesar-empereur/read-book/blob/master/photo/distri/分布式事务.png)

## 微服务的远程调用与事务的设计

- 分布式事务的2种一致性的方式

  |方案 |定义 |适用场景|
  |----|----|----|
  |**[快速失败]()**|某个服务出现异常之后，回滚本地事务|事务一致性要求高的|
  |**[最终一致性]()**|业务一致向前重试，补偿,不向后回滚|事务不要求及时的一致性|
  

- **[保证分布式的服务之间的事务一致性的几种方案]()**
  - **[使用分布式事务]()**
  - **[使用本地消息表]()**
  - **[使用事务消息]()**
  
## **[使用分布式事务]()**
- 分布式事务的理论方案
  - XA(mysql本身支持的)
  - 2PC
  - 3PC
  - TCC
- 分布式事务的成熟框架---seata
  - Seata 是一款开源的分布式事务解决方案，提供了 AT，TCC，SAGA，XA 事务模式
  - 默认AT模式
    - AT模式需要数据库支持ACID事务，对业务代码没有侵入性
    - AT模式没有侵入性的原理是给用一个代理的 DataSource 代替应用原来的 DataSource
    - 这个代理的 DataSource 会把业务的sql解析出一份回滚的 undo log日志
    - 并且把这个回滚日志与业务操作放到一个本地事务里面
    - undo log 保存了数据修改前后的镜像版本
    - 全局事务提交时，会自动删除 undo log 的纪录
    - 全局事务回滚时，会自动根据 undo log 执行对应的补偿 sql, 执行前会对比镜像前的数据与当前数据是否一样
    - 不一样说明全局事务执行期间，数据被修改过，需要指定对应的策略
    ![2pc](https://github.com/caesar-empereur/read-book/blob/master/photo/distri/seata-at模式.png)
  - SAGA 模式
    - Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务
    - 当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现
    - 相当于执行 T1-T2-T3-T4 的事务过程时，T3出现异常，需要回滚，要从T3-T2-T1往前补偿
  - XA 模式
    - 利用数据库对XA协议的支持，机制来管理分支事务的模式
    - XA模式需要使用对应的 XAConnection, XAStatement, XADataSource接口
  - seata 各个模式的对比
    
    |方案 |定义 |适用场景|
    |----|----|----|
    |AT|默认模式，生成对应undo日志，成功自动删除undo日志，回滚根据undo自动补偿|适合数据库支持ACID事务的，对业务代码无侵入|
    |TCC|2阶段提交的模型，1阶段prepara,2阶段commit,rollback,需要将业务代码改造成3个对应的接口，自己做补偿操作|适合不支持ACID事务的数据库|
    |SAGA|SEATA提供的长事务解决方案|业务流程长，多，公司的老系统，无法提供改造 TCC 的接口|
    |XA|需要了解mysql的xa模式的接口和提交流程|事务不要求及时的一致性|



## **[使用本地消息表]()**
- 本地消息表的方案的思想是向前补偿直到最终一致性，不要向后回滚
- 向前补偿的方式有 定时任务检查，人工接入等
- 发送mq消息要放在本地事务里面，有可能消息发出去了，本地事务超时回滚，消息回滚不了，没法补偿
- 因此发送mq消息要放到本地事务之外
- 本地消息表的整个流程最终是形成一个闭环
    ![2pc](https://github.com/caesar-empereur/read-book/blob/master/photo/distri/本地消息表实现分布式事务.png)
  

## **[使用事务消息的最终一致性]()**
- 最终一致性的方法是没法回滚的，只能一直向前重试或者补偿(定时，人工)
- 有些业务错误是没办法向前补偿的，例如单据重复之类的，这种需要调用方也要回滚事务
