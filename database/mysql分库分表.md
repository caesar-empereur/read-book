* 分库分表按照业务方式有2种
   * 水平切分 : 将一个表的数据分成多个表存储，多个表的结构相同，例如订单表按照月份或者id切分为多个表
   * 垂直切分 : 将一个表的字段分成多个表来存储，每个表的数据都是对应字段的全部数据
* 按照物理存储的方式切分
   * 单库多表，虽然分成了多个表，单表查询压力降低，但是多表用的还是同一个数据库实例，负载能力提高不大
   * 多库多表，将多个切分的表分散到多个数据库实例中，降低单个数据库实例的处理压力，提高整个数据库系统的处理能力

- 分库分表的实际方案(需要解决的问题)
    - 分片的方案
        - 根据分片字段的大小范围进行分散
            - 如果你的id是自增的，而且能保证在进行分库分表后也是自增的，那么能进行很好的改造
            - 以id大小水平切分，而且极有可能不用迁移数据
            - 因为新的数据(热点数据)总在一个库里，很可能导致热点过于集中
        - 根据分片字段的取模进行分散
            - 将id mod n，然后放入数据库中，这样能够使数据分散，不会有热点的问题
            - 在扩容的时候，是否会有数据迁移的问题，一般的扩容，当然是会有数据迁移的
    - 扩容的方案
        - 根据表的数据增加库的数量(表数量不变，库数量成倍增加)
            - 核心就是表数量不变，通过增加库的数量，把表逐步分散到多个库中
            - 原来的一个库存多个表，扩容后可能一个库只存一个表
            - 库的扩容方式是每次增加一倍，分库的取模方式 用(id%4)/2，因为 对4，对2取模结果是一样的
        - 每次成倍的增加库与表的数量
    - 历史数据迁移
        - 扩容的数据迁移是跟分片方案息息相关的，有一种方式可以实现部分扩容不用迁移数据
        ```
        有2个库的时候，分库的取模方式 用(id%4)/2，扩容的时候不是增加一个库，而是增加2个库。
        这样 重新取模的时候用 id%4，因为 对4，对2取模结果是一样的，因此历史数据不用迁移。
        但是这个方案只能维持到一个分库范围内，大于4的时候就要迁移历史数据了
        ```
        - 历史数据迁移比较安全的方式是整张表的迁移
    - 分布式事务
* 分库分表需要面对的问题与解决方案

    |问题|解决方案|
    |----|--------|
    |原先的事务会变成分布式事务，需要有分布式事务的方案|XA协议或者2阶段提交，成熟产品有seata|
    |'|关联字段冗余|
    |跨节点关联JOIN查询问题|分次查询(第一次查出对应数据，拿出关联字段再查一次)|
    |'|全局表，将所有需要关联查询的表每个节点都存放一份|
    |'|排序字段为分片字段时，通过分片规则就比较容易定位到指定的分片|
    |跨节点排序，分页问题|排序字段为非分片字段时，需要先在分片节点将数据进行排序，然后将分片返回的结果集进行汇总和再次排序|
    |表的主键的全局唯一性问题|表原先的主键为自增的话就要重新设计，需要使用分布式的全局唯一UUID|
    |非分片字段的查询问题|需要在所有的库中执行对应的order by limit操作后返回，然后再同一计算合并结果返回客户端|
    
* mycat 对分表问题的处理
  
    |问题|解决方案|
    |----|--------|
    |非分片字段查询|Mycat无法计算路由，便发送到所有节点上执行,返回结果统一处理|
    |分页排序|Mycat在处理有偏移量的排序分页是另外一套逻辑——改写SQL，limit m,n会变成 limit 0, m+n |
    |跨节点关联JOIN查询问题|单库中的关联查询都查不出，mycat也会查不出来，如果有关联查询，考虑放弃|
    |分布式事务|只保证 prepare 阶段数据一致性的 弱XA事务 |
