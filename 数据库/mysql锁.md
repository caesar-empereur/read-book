## mysql 锁

* 死锁

  |定义|解决方案|
        |-----------|-------------------|
  |2个事务因争夺资源造成互相等待，没有外力作用无法推进下去|超时机制，超过等待时间就释放，另一个事务也能进行|

* 死锁示例

  |时间|事务A|事务B|
  |-----------|-------------------|---------|
  |t1 |select * from table_a where a=1 for update|'|
  |t2 ||select * from table_a where a=2 for update|
  |t3 |select * from table_a where a=2 for update|'|
  |t4 |'|select * from table_a where a=1 for update|
  |t5 |'|error, deadlock|
* **[死锁排查](#)**
    * 查询是否锁表：show OPEN TABLES where In_use > 0;
    * 查看正在锁的事务：SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
    * 查看锁阻塞线程信息：show processlist， 查询到相对应的查询线程id，然后 kill id
    * 查看当前存储引擎的状态： show engine innodb status，包括事务，锁
- mysql 开启死锁检测
    - innodb_deadlock_detect 设置为ON，发现死锁后，主动回滚死锁链条中的某一个事务
    - 但是死锁检测需要消耗大量的CPU操作，因为每个进来的线程都要检测自己的加入导致当前死锁
- **[怎么避免行锁对性能的影响](#)**
    - **[innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是根据主键索引逐行扫描 逐行加锁，释放锁](#)**
    - **[多个事务更新同一行，不会死锁，只是锁等待，但是更新多行，就会造成循环等待，就是死锁](#)**
    - 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放
    - 行纪录的锁，可以从设计上将一行纪录变成多行纪录来减少死锁冲突
    - 例如一个商家的余额纪录，分成多行纪录，算总余额的时候加起来，增加余额的时候随机加一行纪录
    - **[按照顺序加锁来避免死锁。比如都是按照先拿t1,再拿t2](#)**

- **[锁](#)**
    - **[锁是用来处理多个并发读写的请求](#)**，如果并发只有读，是不用锁的
    - 并发的读是共享锁，是可以并发执行的
    - 并发的请求有写的时候，就是排他锁，一个锁释放了另一个才能执行

- **[间隙锁与幻读](#)**
    - 幻读
        - 幻读出现的条件
        ```
        可重复读的情况下，普通的查询是快照读，是不会看到别人插入的新纪录的，因此幻读是在 当前读的条件下，也就是 select for update
        通过修改数据达到满足 select for update 条件返回导致多出来的数据不能称为幻读，幻读是针对插入的
        
        幻读的一个原因是行锁只能锁住行纪录，行记录之间的间隙无法控制，被插入新纪录之后范围查询，后面查出来
        会出现多出来的纪录，类似幻觉
        ```
    - 间隙锁
        - 间隙就是索引树中行记录之间的空隙，行锁是存在索引上的，只能锁住行记录，间隙锁才能锁住新纪录的插入
        - 间隙锁 和行锁组成了next key lock，目的是为了防止阻止新纪录的插入导致的幻读，间隙锁是在重复读的隔离级别才有的
        - 非唯一索引的辅助索引在间隙锁里面，是会出现多个间隙锁的，需要把满足条件的行记录组成的间隙都锁住
        - **[update 的条件没索引就是锁住主键索引上满足条件的行和间隙，锁内容太多，容易造成死锁](#)**
        - 查询的间隙锁与一个事务中的多次查询的关系
            - **[间隙锁会导致其他事务的更新或者插入造成阻塞，事务中的多次查询只是不同事务的数据可见性](#)**
        ```
        理解间隙的概念必须要知道B树索引的叶子节点是排序的，针对一行纪录的间隙是指这一行纪录的
        左右相邻的值组成的一个开区间，加上右边等值的行纪录锁就形成了闭区间，间隙是左开右闭的
        
        lock in share mode，执行 for update 时，系统会认为你接下来要更新数据，因此会顺便
        给主键索引上满足条件的行加上行锁
        
        间隙锁加锁的条件，只有在查询加上 for update 或者 lock in share mode
        select * from table where c = 7 for update;
        表里面没有 c = 7 的纪录，因此会锁住已有的纪录的 (5, 10) 之间的间隙
        
         查询过程中访问到的对象才会加锁，而加锁的基本单位是next-key lock（前开后闭）
         
         等值查询上MySQL的优化：索引上的等值查询，如果是唯一索引，next-key lock会退化为行锁，
         如果不是唯一索引，需要访问到第一个不满足条件的值，此时next-key lock会退化为间隙锁
         
         范围查询：无论是否是唯一索引，范围查询都需要访问到不满足条件的第一个值为止
         跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系
        ```
      
- 乐观锁与悲观锁
  
  |锁的种类|定义|实现方式|适用场景|
  |------|------|------|-----|
  |乐观锁|认为数据的获取与修改时不会被人改动，但是提交时会校验版本，因此不会上锁|使用版本号或者时间戳，先查出来数据，修改时对比版本号，不一样再重试|适合读取频繁情况|
  |悲观锁|数据的获取与修改悲观的认为会被改动，因此会上锁阻塞，防止别人修改|查的时候 select * for update, 修改的时候提交了锁才会释放，期间别人无法操作|适合写入频繁|

    - 如果数据修改冲突的概率比较大，乐观锁会不断重试，造成冲突，这样性能反而更低，这时悲观锁更合适
    - 
