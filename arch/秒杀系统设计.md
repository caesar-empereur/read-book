## 电商秒杀系统架构

- **[前端](#)**
    - CDN 资源静态化
    - 秒杀连接加密动态话，只能从后端获取，防止连接提前暴露
    - 前端限流，按钮不能重复点击

- 代理层**[限流](#)**
    - **[限流](#)**
        - 对单个IP的请求限流，最多只能请求一次
            - 每个IP都维护一个dict的内存变量，每次校验次数大于1的，统统返回
        - 单个IP限流之后，还要对总的放过去的请求限流
            - 1万人抢100个商品，只需要放1000个人进来就可以了，其余的9000人拦截掉
            - nginx lua 里面做个计数器，请求一次加1，到达1000之后全部返回，不进入后端
        - 经过以上限流之后，，进入后端的并发请求量就大大降低了80%了，反正秒杀对用户来说是黑盒子
    - **[恶意请求识别](#)**
        - 接入风控系统，识别机器人的操作
        - 风控的拦截应该是拦截掉的不能计入限流的总请求数量
    - **[后端逻辑前置](#)**
        -在代理层完成对redis库存的检查扣减，成功的保存对一个list中，这种方式更简单粗暴，不访问后端了
- 后端
    - **[应用隔离](#)**
        - 不仅仅是应用，还有域名都与平时的系统隔离分开部署，出现问题也不会影响到其他的
        - 应用隔离的原因是 tomcat 的线程数，连接数是有限制的，瞬时的高并发请求会影响到其他的功能
        - tomcat 的最大线程数(几百)，连接数是有限制的，因此可能要多部署多个应用组成负载均衡
    - **[读写降级](#)**
        - 数据库是比较薄弱的环节，因此对库存的读写改为缓存
    - **[redis 库存设计(超卖问题)](#)**
        - 队列，在redis的list中lpush 100个商品，减库存的时候 lpop出来，能pop出数据的发一条MQ消息
        - 将 (检查库存，扣减库存，返回) 这3个操作用Lua脚本包住，在分布式环境下也是原子操作，能返回1的发MQ消息
    - **[库存扣减成功的订单处理](#)**
        - 上面的库存扣减成功的发MQ消息，消息包含用户id，因此把并发的对数据库的操纵变成串行的，降低数据库压力
