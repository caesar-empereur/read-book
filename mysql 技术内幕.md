## 1 章 mysql 技术体系

- 1 实例与数据库的区别
  * mysql 数据库是指操作系统文件的集合
  * mysql 实例是系统进程与内存区域的组成
  * 数据库实例才是处理数据的
  
- 2 innodb 存储引擎的特点

  * 支持事务
  * 行锁设计
  * 插入缓冲
  * 二次写
  * 自适应哈希索引
  
- innodb 存储引擎架构

![innodb](https://github.com/caesar-empereur/read-book/blob/master/photo/innodb.png)


## 第 4 章 mysql 数据文件

  * 表都是根据主键顺序组织存放的，这种存储方式的表称为 **[索引组织表](#)**
  * 页 是mysql 磁盘上最小单位的数据存储形式，也叫 块 **[每页的数据大小是16KB](#)**
  * 页存放的行记录也是有硬性定义的，最多允许存放16KB / 2-200行的记录，即7992行记录
  
## 第 5 章 mysql 索引

 * 树的数据结构
   * 平衡二叉树，红黑树等查找算法都是在内存中进行的，适合小文件，不适合磁盘查找的大文件
 * B 树分为 **[B-树](#)**，**[B+树](#)**，但都是 **[多路平衡查找](#)** 的树结构
   * **[B-树](#)** 的一个重要特点是 **[非叶子节点也会存储数据](#)**
   * **[B+树](#)** 的一个重要特点是 **[只有叶子节点会存储数据](#)**，所有叶子节点通过链指针形成 **[排序链表](#)**
    
    ![innodb](https://github.com/caesar-empereur/read-book/blob/master/photo/B+树索引.png)
 * 聚集索引 与 辅助索引
  
  |索引类型 | 定义 |叶子节点存储的东西 | 定位方式 |
  |-----------|-------------------|------------|------|
  |聚集索引| 按照每张表的主键构造一棵B+树 | 行记录 | 通过搜寻聚集索引B树找到行记录 |
  |辅助索引| 按照每张表的主键外的字段构造一棵B+树| 聚集索引的键 | 通过非聚集索引B树找到 聚集索引的键，再通过聚集索引树找到行记录 |
  
>> 辅助索引的先通过找到聚集索引的键再查到到对应行记录的过程，出现了多次IO操作，这个叫 **[回表查询](#)**,  但不是所有辅助索引都要经过回表查询
   ，覆盖索引不需要回表
   
 * 覆盖索引
   * 从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录
   * 使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作
 
 * 哈希索引
   * 哈希表的数据存储是没有任何顺序的，因此哈希索引只有在等值查询才能发挥作用，范围查询与排序是失效的，联合所以最左匹配也不行
   
 ## mysql 死锁
    
  * 死锁
  
      |定义|解决方案|
      |-----------|-------------------|
      |2个事务因争夺资源造成互相等待，没有外力作用无法推进下去|超时机制，超过等待时间就释放，另一个事务也能进行|
      
  * 死锁示例
  
      |时间|事务A|事务B|
      |-----------|-------------------|---------|
      |t1 |select * from table_a where a=1 for update|'|
      |t2 ||select * from table_a where a=2 for update|
      |t3 |select * from table_a where a=2 for update|'|
      |t4 |'|select * from table_a where a=1 for update|
      |t5 |'|error, deadlock|
      
## 第 7 章

* 事务的特性
 
  |特性|描述|
  |-----------|-------------------|
  |原子性|一个操作，要么成功，要么失败,没有中间状态|
  |一致性|从一个状态到另一个状态的一致性|
  |隔离性|事务与事务之间的操作不能互相影响|
  |持久性|事务一旦提交就应该永久保存|

* 事务的分类

    |事务|描述|
    |-----------|-------------------|
    |扁平事务|事务由多个操作组成，一旦回滚必须回滚所有操作，代价很大|
    |带有保存点的扁平事务|回滚时可以只回滚最新的保存点，但是系统奔溃，所有保存点都会消失|
    |链式事务|提交事务操作和开始下一个事务操作将合并为一个原子操作|
    |嵌套事务|父事务包含子事务，子事务的提交必须在父事务提交才能生效,一个子事务回滚，其他子事务也会回滚|
    |分布式事务|事务的多个操作分布在多个服务器上|
    
- 事务的实现

    - 事务的 **[原子性](#)** 是通过 **[undo log](#)** 来实现的
    - 事务的 **[持久性](#)** 是通过 **[redo log](#)** 来实现的
        - **[原子性和一致性是为了保障数据可靠性，宕机恢复以及回滚](#)**
        - **[隔离性是为了处理多个并发读写的请求](#)**
    - **[事务的隔离性是通过 (读写锁+MVCC)来实现的](#)**
    - **[事务的一致性是通过原子性，持久性，隔离性来实现的](#)**
  
    - **[日志文件的事务实现](#)**
    
       |'|redo|undo|
       |-----------|-------------------|-------|
       |定义|redolog称为重做日志，用来保证事务的 **[持久性](#)**|undo log用来保证事务的 **[原子性](#)**|
       |记录的状态|redolog 记录的是修改后的数据|undo log记录的是修改前的数据|
       |日志类型|redo通常是物理日志，记录的是页的物理修改操作(不是操作的语句)|undo是逻辑日志，根据每行记录进行记录|
       |执行过程|redo 每次事务提交时要将所有操作写入重做日志缓冲区，再刷新到重做日志缓冲文件|undo是需要回滚时执行，回滚不是将执行语句撤销，而是执行与语句相反的语句，insert回滚时会执行delete|
   
   - **[锁](#)**
       - **[锁是用来处理多个并发读写的请求](#)**，如果并发只有读，是不用锁的
       - 并发的读是共享锁，是可以并发执行的
       - 并发的请求有写的时候，就是排他锁，一个锁释放了另一个才能执行
   - **[MVCC](#)**
       - 多版本并发控制是为了应对高并发事务, MVCC 比单纯的加行锁更有效, 开销更小
       - 每行数据都存在一个版本，每次数据更新时都更新该版本
       - 每行数据都有隐藏的2个列，创建版本号，删除版本号，每开启一个事务，系统版本号加一
       - 修改时Copy出当前版本随意修改，各个事务之间无干扰
       - 保存时比较版本号，如果成功提交，则覆盖原记录
       - **[MVCC](#)** 只有在 **[读提交](#)** 和 **[重复读](#)** 隔离级别下起作用
       - **[MVCC本质是对已经存在的数据做版本标记，插入数据是没法处理的](#)**
       
   - **[隔离级别与脏读幻读的关系](#)**
                                     
       |读的种类|事务A可读到事务B未提交的|解决办法|原理|办法描述
       |-----------|-------------------|--------|-----|-------------|
       |**[脏读(读未提交)](#)** |**[任何数据](#)**|**[读提交](#)**|**[MVCC](#)**|事务A必须等事务B提交后才能取|
       |**[不可重复读(虚读)](#)**|**[更新数据](#)**|**[重复读](#)**|**[MVCC](#)**|事务A 读提交后，事务B更新操作不可见|
       |**[幻读](#)**|**[插入数据](#)**|**[序列化](#)**|**[锁](#)**|最高级别，事务按照串行执行，安全性最高|
   - MVCC 的读提交与重复读的原理
       - **[重复读](#)** 的读事务开启之后，生成的 **[一致性视图不会改变](#)**，其他事务提交后的版本 **[对当前视图不可见](#)**
       - **[读提交](#)** 的读事务开启之后，**[每次都生成新的一致性视图](#)**，其他事务提交的版本 **[对当前视图总是可见](#)**
- purge

  * delete和 update 并不是直接删除数据，而是将数据打上删除标记，索引页构造的B树对应的键也是删除标记
  * puege 操作用于将 delete update 操作真正删除
  * 这么设计的原因是2为了实现mysql的mvcc，一个事务对某行提交修改时，不会真正删除，其他事务对改行也存在改动，因此需要保存改行的前一个状态，是否真正删除需要puege判断是否有另一个事务对改行操作

- 控制事务的语句
  * mysql 默认情况下，事务是自动提交的
  * START TRANSACTION | BEGIN：显式地开启一个事务
  * ROLLBACK 回滚事务
  * SET TRANSACTION 设置事务的隔离级别
  * 隐式提交事务的 语句 alter table, create index, drop table, drop index
  
  
  
  
  
  
## mysql 分布式事务

>>**[mysql本身是支持分布式事务的，是由 XA 事务实现的](#)**

  * XA事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成
  
    * 资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器
    * 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信
    * 应用程序：定义事务的边界，指定全局事务中的操作
    
  * mysql XA 事务的操作流程
    * XA START|BEGIN xid
    * XA END xid
    * XA PREPARE xid
    * XA COMMIT xid
    * XA ROLLBACK xid
    * XA RECOVER xid
    
>> show variable like innodb_support_xa  可以查看数据库是否支持 分布式XA事务

  * JAVA XA事务的实例
    * javax.sql包下面有分别的对应XA事务的类，XAConnection, XADatasSource, XAResource
    * 分别建立2个数据库的连接，获取到对应的2个，XAConnection, XAResource, Statement
    * 分别执行2个 XAResource.start()-->Statement.execute()-->XAResource.end()
    * 分别执行 XAResource.prepare()
    * 分别判断 2个prepate的执行结果,都是OK的话，就都执行 XAResource.commit(), 否则 XAResource.rollback()
    
  * 不好的事务提交习惯
    * 循环中提交事务
    * 自动提交事务
    * 长事务(执行时间很长的事务)
    
