## 9章 服务器中的数据库

- 切换数据库
    * 客户端 select 命令切换数据库
    * 客户端 redisClient 的 db 属性记录当前指向的数据库，切换就是修改 db 的指向
    
- 数据库键空间
    * 1  redis 服务器中的每个数据库都有一个 redisDb 结构体的 [dict字典]() 保存所有的 **[key-value]()** ,称为键空间, 结构如下

        |键         | 键的数据结构       |
        |:-----------:|:-------------------:|
        |"list"     | 列表               |
        |"hash"     | 哈希表             |
        |"string"   | 字符串             |
    * 2 对 key value 的操作都是修改 dict 字典
    * 3 设置 key 的过期时间
        * redisDb 结构体的 **[expire过期字典]()** 保存了 key 对应的过期时间，结构如下
        
            |键             | 过期时间          |
            |:---------------:|:-------------------:|
            |"name" 键的指针 | 10秒             |
            |"age"  键的指针 | 20秒             |
            |"phone"键的指针 | 30秒             |
            
        * 修改删除过期时间都是对 expire 字典修改
        * 判断 key 是否过期
            * 每次获取 key 判断是否在 过期字典中，没有就直接返回
            * 有的话拿出过期时间与当前时间对比，过期则返回空，是否删除要根据策略

- 过期删除策略

    |删除策略     | 具体操作       | 优缺点   |
    |:------------:|:--------------------|:-------------------|
    |定时删除     | 设置键的过期时间时，创建一个定时器，时间一到就删除                |  内存友好，消耗 CPU  |
    |**惰性删除** | 每次获取key的时候再去检查是否过期，是就删除返回空，没就返回 value  | 占用内存，不消耗 CPU |
    |**定期删除** | 服务器每隔一点时间检查，删除过期键                                |  折中方案           |

- 过期删除对 RDB, AOF 文件的影响
    
     |顺序    | 操作       |
     |-----------|:-------------------|
     |1    | SAVE 命令生成 RDB 文件时，过期的键被检查到，不会写到 RDB 文件中   |
     |2     | redis 以 主 模式载入 RDB 时，过期的键不会载入 |
     |3   | redis 以 从 模式载入 RDB 时，过期键也会载入，等到主删除过期键时，会发送同步命令删除从的 |
     |4   | redis 以 AOF 模式运行时，过期键还没删除的也会写入 AOF, 只有过期时才向 AOF 文件追加 删除命令 |
     |5   | 主 发现并删除过期键时，会同步删除命令到从 |

## 10章 RDB持久化
   * 创建 RDB 文件
      * SAVE 命令，服务器会一直阻塞，期间无法接收命令
      * BGSAVE 命令，新建一个进程，不会阻塞
   * 载入 RDB 文件
      * 开启了 AOF 时，会载入 AOF 文件
      * 没开启 AOF 时，会载入 RDB 文件
      * 载入RDB期间，服务器会阻塞
   * **[RDB文件包含了全部的键值对数据]()**


## 11章 AOF持久化

   * AOF文件保存的是一条条的 **[写命令]()**，服务器每执行一条写命令，都会追加写入到 AOF 文件里
   
   * AOF 文件的载入还原
      * 服务器启动时，**读取AOF文件中的所有命令拿到数据库执行**
      * 命令是通过创建一个不带网络连接的 **[伪客户端]()** 执行的
      
   * **[AOF重写]()**
   
      |顺序    | 操作       |
     |-----------|:-------------------|
     |1     | 对于一个列表类型的键，只需要一条写命令记录全部数据, **多次写操作记录多条写命令**，AOF文件体积会很大|
     |2   | 后台获取键对应的数据后生成一条命令，写入2个缓冲区，后续键的数据有变化时 |
     |3   | 每一条写命令，后台会写入到 AOF **[缓冲区]()** 与 **[AOF重写缓冲区]()** |
     |4   | 两个缓冲区的数据都会写入到对应的文件，重写结束时，重写缓冲区文件替换掉 缓冲区文件 |

## 15章 复制(主从复制)

>> Redis的 **[复制]()** 功能分为 **[同步sync]()** 和 **[命令传播]()** 两个操作

>> **127.0.0.1:6378 > SLAVEOF 127.0.0.1:6379** ==> 6378 复制 6379

* **[同步]()** 操作用于将从的数据库状态更新至主当前所处的数据库状态
    
    |顺序    | 操作       |
     |-----------|:-------------------|
     |1    | 从向主发送SYNC命令   |
     |2     | 收到SYNC命令的主执行BGSAVE命令，在后台生成一个RDB文件 |
     |3   | 将BGSAVE命令生成的RDB文件发送给从 |
     |4   | 从将自己的数据库状态更新至主执行BGSAVE命令时的数据库状态。 |


- **[命令传播]()**

>> 目的 ：同步操作后致主从的数据库状态出现不一致时，让主从的数据库重新回到一致状态。

    * 1 主数据变化后，会将自己执行的写命令发送给从服务器执行
    * 2 当从执行了相同的写命令之后，主从将再次回到一致状态
    * 在命令传播阶段，从会以每秒一次的频率，向主发送命令

- **[旧版同步操作缺陷]()**

    |旧版同步操作 | 缺点       |
     |-----------|:-------------------|
     |主从同步过一次后断线再进行同步，会执行上一步的同步的内容 | 没有必要，需要的是需要同步断线后主变动的数据   |
     |同步操作耗时耗资源，需要主 执行 BGSAVE生成RDB文件传输给从 | 消耗CPU内存磁盘资源 |
     |从 接受到RDB文件后载入RDB文件| 这时服务器会阻塞，无法处理客户端请求 |


> Redis从2.8版本开始，使用 **[PSYNC]()** 命令代替SYNC命令来执行复制时的同步操作

- **[PSYNC]()** 命令具有 **[完整重同步]()** 和 **[部分重同步]()** 两种模式

    |PSYNC     | 初次复制       | 断线后重复制   |
    |:------------:|:--------------------|:-------------------|
    |完整重同步     | SYNC命令的执行一样，都是通过让主创建并发送RDB文件  |  '  |
    |部分重同步 | '  | 主从断开后, 主将断开期间主执行的写命令发送给从，从只要接收并执行这些写命令 |
    
    * **[部分重同步的原理]()**
        

        |顺序    | 操作       |
        |-----------|:-------------------|
        |1    | 主和从会分别维护一个复制偏移量   |
        |2     | 主每次向从传播N个字节的数据，就将自己的偏移量的值加上N |
        |3   | 从每次收到主传播来的N个字节的数据时，就将自己的偏移量的值加上N |
- PSYNC 命令的实现
    * PSYNC 从服务器 命令的调用方法有两种
        * 如果从以前没有复制过任何主, 从在开始一次新的复制时将向主发送PSYNC -1
        * 如果从已经复制过某个主，那么从在开始新的复制时将向主发送PSYNC ＜runid＞ ＜offset＞
    * PSYNC 主服务器返回3种回复
        * 如果主返回+FULLRESYNC runid offset，那么表示主将与从执行完整重同步操作
        * 如果主返回+CONTINUE回复，那么表示主将与从执行部分重同步操作
        * 如果主返回-ERR回复，那么表示主的版本低于Redis 2.8
        
- 主从复制
    - **[主从复制模式中包含一个主与一个或多个从]()**
    - 流程
        - slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照
        - master将保存的快照文件发送给slave，并继续记录执行的写命令
        - slave接收到快照文件后，加载快照文件，载入数据
        - master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化
        - 此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性
    - 优点
        - master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
        - master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
    - 缺点
        - **[不具备自动容错与恢复功能]()**，master或slave的宕机都可能导致客户端请求失败
        - master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
        - **[难以支持在线扩容]()**，Redis的容量受限于单机配置
## 16章 sentinel 哨兵模式
- 哨兵模式
    - **[哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障]()**
    * 哨兵是 redis 的高可用解决方案
    * 一个或多个 哨兵实例组成哨兵系统，监控多个主从
    * 发现主服务器下线时，将某个从升级为主
    * sentinel 向多个从发送 复制 指令，故障转移完毕
    * 之前掉线的主恢复上线时，设置为从
    
- 哨兵模式的部署
    - 部署的时候需要指定哨兵的实例，监控哪个master节点
- 哨兵模式的工作流程

    * 1 启动初始化 sentinel
        
        |顺序    | 操作       |
        |:-----------|:-------------------|
        1    | 初始化服务器，sentinel 是一个运行在 **[特殊环境]()** 下的 redis 服务   |
        2     | 将 redis 服务变成 sentinel 服务，sentinel 模式下，无法执行 set get 命令 |
        3   | 初始化 sentinel 状态下的 master 属性，记录了主服务器地址 |
        4   | 连接到 主，成为主的客户端，用来发送命令 |
    * 2 获取 主服 信息
        * 2.1 定时通过发送 INFO 命令到主来获取主服务器的信息
        * 2.2 主返回的信息包括主自己的信息，还有主下面的从服务器的地址状态等信息
    * 3 sentinel 发送 ping 命令到各个 redis 服务器，规定时间内没有返回回复的判断为 **[主观下线]()**
    * 4 sentinel 询问其他 sentinel 主观下线的 redis 服务是否也是下线，是的话就是 **[客观下线]()**
    * 5 选举领头 sentinel
        * 5.1 每个发现客观下线的 sentinel 都会发命令要求其他 sentinel 将自己设置为 领头 sentinel
        * 5.2 **[发命令是先到先得]()**，谁先发，谁先成为 领头
    * 6 **[故障转移]()** (领头sentinel选举后，需要对下线的主执行故障转移)
        
        |顺序    | 操作       |
        |-----------|:-------------------|
        |1    | 在主下的从里面，选一个变成主 |
        |2     | 让旧的从复制新的主数据 (修改之前的复制目标) |
        |3   | 下线的主设置为从，上线时再去复制新的主 |
- 哨兵模式的优缺点
    - 优点
        - 哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有
        - 哨兵模式下，master挂掉可以自动进行切换，系统可用性更高
    - 缺点
        - 同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置
        - 需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务
        
## 17章 集群
> redis 集群可以提供相对于单机更可靠的服务

- 1 集群模式的建立
    * 1.1redis 服务启动时检查配置项 cluster-enable 是否开启
    * 1.2开启的话读取集群的地址信息，发送命令到指定服务器 CLUSTER MEET 建立连接创建集群
    * 1.3这时集群还不是上线状态
    
- 2 **[redis 为什么不用简单哈希处理 key？]()** 
    - 简单哈希就是对节点数量取模算出哪个节点来处理 key
    - 5个节点，set 命令保存数据分配到第一个，节点数量变化了，get 命令取模计算的时候算出来第二个，找不到数据了
    - 总结就是简单哈希在节点数量变化时会出现前后2次算出的节点不一样，导致set, get 操作拿不到 value
    
- 3 **[一致性哈希]()**
![一致性哈希](https://github.com/caesar-empereur/read-book/blob/master/photo/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.png)

- 4 **[redis没有采用一致性哈希，而是用哈希槽的方式]()**

    - redis 为什么不采用一致性哈希？
        - 一致性哈希是一个环，节点数量少的时候，可能会出现数据倾斜的问题
        - 适用哈希槽的一个好处就是无论节点数量多少，都可以实现槽的均匀分布
        - 一致性哈希适合无状态的负载均衡，redis服务是有状态的，节点出现故障
    * 1 redis 集群通过 **[分片, 槽指派]()** 来保存数据，整个集群分配了 16384 个槽用来存储数据，**[每个节点处理一部分槽]()**
    * 2 **所有槽都有服务器接受处理时 集群才是上线状态**，只要有一个槽没人接收处理，就是 下线
    * 3 可以向集群下的节点发送命令，**指定节点处理的哪些槽** CLUSTER ADDSLOTS 0 1 2 ...5000
    * 4 每个节点记录自己的槽信息，**还会向其他的节点传播自己的槽信息**，节点两两互相传播
    * 5 **[重新分片]()**
        * **[当集群节点数量变化时，将某个节点下的一些槽重新分配到另一个节点，槽对应的key数据也会随着迁移]()**
        * 重新分片不需要集群下线，移动哈希槽的成本是非常低的
        * 重新分片操作是由Redis的集群软件redis-trib负责执行的

- 3 **[在集群中执行命令，key 的处理过程]()**
    - 虽然是集群模式，但是执行命令时仍然需要指定哪个节点处理
    * 1 某个节点接收到数据处理命令时，先算出 key 所属的槽是不是自己负责的，是的就处理数据
    * 2 不是自己负责的，找到槽对应的节点，返回客户端 **[MOVED]()** 错误 和 **[重定向]()** 指令
    * 3 **集群模式下客户端不会打印这个 MOVED 错误**，而是直接重定向到指定服务器 操作数据
    * 4 单机模式下，判断到key所属的槽不是自己的，客户端直接打印错误
   
   |'     | redis-trib 操作       | '   |
    |------------|:--------------------:|-------------------|
    |源节点     | ---->导入哪些槽      | **[1](#1)** 目标节点  |
    |源节点 **[2](#2)** | 导出哪些槽----->  | 目标节点 |
    |源节点 **[3](#3)** | 迁移槽对应的键数据------>   |  目标节点           |
    |源节点 | **[4](#4)** 通知整个集群 : 哪些槽被迁移到哪里   |  目标节点           |
    
- 5 **[复制]()** 与 **[故障转移]()**
    
    * Redis集群中的节点分为主节点和从节点
    * 其中 **[主节点用于处理槽]()**，**[而从节点则用于复制某个主节点]()**
    - 主节点用于处理命令，从节点不会处理请求命令
    * 主节点下线时，代替主节点继续处理命令请求
    
      | 模式的区别| 优缺点 |措施 |
      |-----------|-------------------|-------------------|
      |Sentinal | 高可用 |在master宕机时会自动将slave提升为master，继续提供服务 |
      |Cluster| 扩展性 |单个redis内存不足时，使用Cluster进行分片存储 |
 
## 19章 事务

- 1 事务的实现
    * 1.1 **[MULTI]()** 开始事务
    * 1.2 命令入队，**EXEC、DISCARD、WATCH、MULTI** 这4个命令会被马上执行，其他的命令会 返回 **QUEUED** 回复
    * 1.3 执行事务，EXEC 命令将队列的命令执行
    
```
WATCH命令是一个乐观锁，可以在EXEC命令执行之前，监视数据库键，并在EXEC命令执行时，
检查被监视的键是否已经被修改过，如果是的话，服务器将拒绝执行事务，
并向客户端返回代表事务执行失败的空回复
```

- 2 watch 命令的实现

    * 2.1 watch 命令的执行

        | 客户端A         | 客户端B         |
        |---------------- |-----------------|
        |watch "name"     |                 |
        |multi            |                 |
        |set "name" "hehe"|                 |
        |'                |set "name" "haha"|
        |返回 error       |                 |

    * 2.2 watch 命令的实现
        * 2.2.1 每个redis 服务器都会保存一个 watched 字典,结构如下

            | 键        | 监控的客户端<链表> |
            |-----------|-------------------|
            |"name"     | 客户端A -> 客户端B |
            |"age"      | 客户端C            |
            |"phone"    | 客户端D -> 客户端E | 

        * 2.2.2 watch 字典的检查过程
            * 1 所有对键数据修改的命令，都会检查服务器上的 watched 字典
            * 2 如果修改的键在字典中有，就会修改对应客户端的 一个 DIRTY_CAS 标记为 TRUE
            * 3 客户端发送到服务器的执行命令，服务器发现 DIRTY_CAS 为 TRUE, 说明安全性被破坏，返回错误
            
## redis 回收策略

- **[如何保证redis中10w数据都是热点数据？]()**
    - 数据库中有1000w的数据，而redis中只有50w数据，如何保证redis中10w数据都是热点数据？
    - 限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，留下热数据到内存
    - 计算一下 50W 数据大约占用的内存，然后设置一下 Redis 内存限制即可
    - 并将淘汰策略为volatile-lru或者allkeys-lru

| 回收策略   | 回收源 | 具体措施 |
|---------------- |-----------------|-----------------|
|volatile-lru | 设置过期时间的数据集 | 挑选最近最少使用的数据淘汰 |
|volatile-ttl |设置过期时间的数据集 | 挑选将要过期的数据淘汰 |
|volatile-random| 设置过期时间的数据集 | 任意选择数据淘汰 |
|allkeys-lru |数据集| 挑选最近最少使用的数据淘汰 |
|allkeys-random| 数据集 | 任意选择数据淘汰 |
|no-enviction|                 | 禁止驱逐数据 |


>> LRU（Latest Recent Used)

## redis 缓存时间与一致性问题

-
| 问题        | 描述 |解决方案|
|-----------|-------------------|-------------------|
|缓存穿透 | 一直查询缓存与数据库都没有的数据,每次都查2个地方，导致后端压力过大 |参数校验，key id<0直接返回，布隆过滤，用算法判断key在缓存种是否存在，不用直接查 |
|缓存雪崩 |大面积的key过期导致缓存挂掉导致所有请求转到数据库，造成数据库压力过大 |每个key过期时间不一样,分散开 |
|缓存击穿 | 热点key在某个时间内失效，有大量并发请求过来了，造成DB压力 | 布隆过滤，key获取value值为空时锁上，从数据库中load数据后再释放锁，其他线程等待锁释放 |



## redis 单线程
- 为什么单线程的redis还这么快?
    - redis 的单线程是指 接收，读取，解析，返回都由主线程完成
    - 纯内存操作，没有磁盘访问，CPU 不是瓶颈
    - 其二就是异步IO，redis 中主要的IO 操作是 接收和返回
    - redis 中的IO 模型是非阻塞的，是 epoll 模型
    - 单线程避免了单线程的上下文切换，锁的竞争，内核态到用户态的切换
    - redis 处理的大部分时间消耗在 io 的读写上
    - 如果单线程还满足不了，可以集群模式，多进程单线程，处理能力提高
    
- redis 6.0 引入了多线程机制的原因
    - 配置文件里面加入  io-threads 4 开启4个io线程
    - 多线程加入之后的流程：
        - 主线程负责连接建立和读写事件
        - 主线程发现连接可读后，将连接加入等待队列，等待队列将连接分配 io 线程处理
        - io 线程读取数据，处理完成
        - 主线程等待所有 io 线程处理完之后，清空等待队列
        - redis 引入多线程后不会有并发问题，因为处理命令的还是单线程

## redis **[pipeline]()** 机制
```
普通的redis操作是一次请求，一次处理返回
当连续多次操作redis时，顺序执行需要等待每一步执行完才能下一次操作

pipeline 机制可以实现一次将多个redis操作变成一次请求，不需要等待，最后一次性处理即可

pipeline 机制可以提高吞吐量，但无法保证原子性，事务
```

## redis 的数据结构总结
- string
  - redis 的字符串处理没用c语言的字符串，而是用了简单动态的字符串
  - 不用担心字符串变更导致内存溢出
  - 常数时间复杂度获取字符串的长度
  - 空间预分配，防止多次重分配内存
- list
  - redis 的list是用双向链表实现的
  - redis 3.0之后不用链表实现 list了，改用 quicklist
  - 
  - 
- hash
  - redis 的hash就是哈希表，数组加上单向链表的结构
  - 链地址法解决哈希冲突，链表没有用红黑树优化
  - rehash优化，将数据迁移中的大批量操作分摊到每一次的key操作中
  
- set
  - 由 ziplist 组成的
- zset
  - set 的元素是不能重复的，zset 的元素除了不能重复，还有排序的性质
  - zset的底层编码有两种数据结构，一个ziplist，一个是skiplist
  
- bitmap 布隆过滤器
- geo
    - geo 是跟地理位置相关的，常见用于附近的人，或者美团上附近的商家距离多远
    - Redis 的 Geo 是在 3.2 版本才有的
    - geoadd 命令(添加经纬度坐标)
        - geoadd cityGeo 116.405285 39.904989 "北京"
        - geoadd cityGeo 121.472644 31.231706 "上海"
    - geopos 命令(返回经纬度坐标)
        - geopos cityGeo 北京
    - geodist (返回2个位置的距离)
        - geodist cityGeo 北京 上海 km
    - georadius (获取某个位置为中心，半径多少内符合条件的位置列表)
    - geohash
    - geo 是将二维的坐标编码为一维的数据然后存储到 zset 结构的
- hyperlog
    - HyperLogLog 是一种算法，它提供了不精确的去重计数方案
    
## redis 依赖的数据结构
- skiplist
    - 跳表就是链表与二分法的结合，目的是提高访问的效率，时间复杂度 log(n)
      ![https](https://github.com/caesar-empereur/read-book/blob/master/photo/redis/skiplist.png)
    - 跳表的思想就是在原有的有序的链表上构建节点数逐步减少的多层次的链表
    - 跳表的元素的访问是通过在最上级的链表逐步比较，依次向下访问定位，最终找到指定元素
    - 为什么要使用跳表，而不使用二叉树或者哈希表？
    - 哈希表的访问时间复杂度是O(1),但是元素的存放是无序的，不能范围查找
    - 二叉树或者平衡树在树的节点变化移动之后，维持平衡需要重新变换节点位置，消耗性能
- ziplist
    - ziplist是由一系列特殊编码的连续内存块组成的顺序存储结构，类似于数组，ziplist在内存中是连续存储的
    - 但是不同于数组，为了节省内存 ziplist的每个元素所占的内存大小可以不同,设计目标就是为了提高存储效率
    - 普通的双向链表，链表中每一项都占用独立的一块内存，之间用指针连接起来。这种方式会带来大量的内存碎片
    - 而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存
    - redis 的list, hash, zset 都使用了该数据结构
    - ziplist结构由三大部分组成，其分别是列表头（ziplist Header），数据节点（Entries）和列表尾（ziplist tail）
    - 往ziplist里插入一个entry 时间复杂度 平均:O(n), 最坏:O(n²)
    - 从siplist里删除一个entry 时间复杂度 平均:O(n), 最坏:O(n²)
    - ziplist 每次的数据变动都可能引发连续更新
- quicklist
    - quicklist 是一个双向链表，是由 ziplist 组成的，每个节点都是一个 ziplist 组成的
    - ziplist 本身是一个有序的内存紧缩的列表
    - quicklist 为什么这么设计，因为 linklist 内存空间不连续，除了数据还有指针空间消耗大
    - ziplist 数据变动时可能会引发连续更新，降低性能
    - quicklist 就是综合2个因素做的设计
    - quicklist 每个节点上的 ziplist 长度是可以配置的
