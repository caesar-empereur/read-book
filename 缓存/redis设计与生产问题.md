## redis 与 mysql 双写数据一致性的问题
```
在高并发的业务场景下，数据库的性能瓶颈往往都是用户并发访问过大。所以，
一般都使用redis做一个缓冲操作，让请求先访问到redis，没有数据再访问 mysql,
更新的时候先更新mysql 再更新缓存。而不是直接去访问MySQL等数据库。从而减少网络请求的延迟响应
```
- **[数据为什么会不一致？]()**
    - 场景 1
        - **[更新mysql后更新到redis的时候更新应用挂掉了]()**
            - A线程要做数据更新，先更新数据库，然后更新到redis的时候更新应用挂掉了
            - B线程进来之后读取到redis的数据，但是跟数据库不一致的
        - 解决办法
            - 更新到数据库之前删除redis，再更新数据库，这样再更新到redis出问题也不会不一致
    - 场景 2
        - **[2次删除的第二次删完redis之后又被其他线程更新旧的mysql数据到redis]()**
            - A的第二次删除之后更新到redis
            - B在A更新到数据库之前拿到旧的mysql数据，又在A第二次删除之后更新了redis，redis出现旧的数据
              ![延时删除](https://github.com/caesar-empereur/read-book/blob/master/photo/redis延时删除.png)
        - 解决办法
            - 第二次删除redis数据之前停顿一段时间
    - 其他需要注意的设计
        - 缓存设置失效时间，业务线程去从数据库更新到缓存的弊端
            - 一旦缓存失效，短时间内没有更新到缓存，请求都进入数据库
            - 数据库如果是集群模式的，可能单点故障，就会出现整体不可用又拖累数据库的结果
            - 解决办法，缓存不设置失效时间，缓存更新然后台线程去更新，而不是业务线程

## redis 其他问题

- redis 异步队列的实现
    * 用一个 list 结构的 key，rpush 消息，lpop 消息，没有获取到消息，sleep 一下
- redis 与 mysql 数据一致性
    * 读是先读缓存，写是先写数据库再更新
    * 强一致性要求的场景不能使用 redis 缓存
- **[布隆过滤器]()**
    - 布隆过滤器一种比较巧妙的概率型数据结构
    - 当它判断存在时不一定 (**[误判]()**)，不存在则是确定的
    - 实现原理是 **[位图]()** 与 **[哈希函数]()**
        - 先不断的存储字符串到位图中，哈希函数算出key的多个位
        - 然后判断这些位是不是已经被设置为1，其实就是与位图的位进行与操作
        - 多个哈希函数算出来的多个位只要与操作之后多个位全部改变，就证明这个key不存在
        - key 不存在添加成功，相当于 map 的 putIfNotExisted()
    - redis 有插件支持，key add 进去，判断是否存在是 用 exist
    - 用一个位数组和n个哈希函数，算出key 的哈希取模，得到n个数组索引值，把这些值置为1
    - 判断存在时也是用哈希取模的方式算出n个索引值，每个都为1则元素存在，有一个为0则不存在
    - 由于是哈希计算，**[时间复杂度为 O(1)]()**
    - 100亿个key, 每个key 64字节，布隆过滤器大小为25GB，远小于使用哈希表的640GB
    - 布隆过滤器可用于过滤网站黑名单，垃圾邮件，商品是否重复购买
- **[redis 热点数据失效怎么处理]()**
    - 热点数据失效了，那就不要让它失效，不要设置失效时间
- **[redis 怎么发现热点数据？]()**
    - 电商的热点商品的访问需要做成redis数据，怎么判断哪些商品的缓存key是热点的？
    - 1 认为预测
    - 2 系统推算统计(根据日志，访问统计)
    - 3 redis 内存淘汰机制设置为 allkeys-lfu, 再执行 ./redis-cli --hotkeys 就会返回访问量大的key
- **[热门商品的热点key大部分集中在redis集群的某个结点上，造成单点瓶颈怎么处理？]()**
    - 多级缓存也叫本地缓存，也就是缓存前置
        - 应用本地使用缓存，热点key的访问就分散到每个应用上了
        - 多级缓存适合变动少的数据例如商品详情，库存数据的变化大，就需要短时间内更新一次
        - 本地缓存的更新策略分为主动更新与被动更新
        - 主动更新就是在更新redis的key时，异步的更新应用的本地的缓存数据
        - 被动更新就是单位时间内缓存过期，则穿过本地缓存直接取到redis的数据然后更新到本地
        - 在回源到redis期间，保证每个应用只有一个线程在操作，防止大量请求到redis
    - redis 集群模式一主多从，读写分离方案

## redis 生产问题
- 阿里云redis集群对lua脚本调用的限制
- springboot 单节点配置连接到 haproxy 对redis集群的key的重定向导致key找不到
- Could not get a resource from the pool#012#011at redis.clients.util.Pool.getResource
