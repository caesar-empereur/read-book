- TCP IP 分层模型
    ![tcp分层](https://github.com/caesar-empereur/read-book/blob/master/photo//tcp/tcp分层.png)
- TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
    - 面向连接：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息
    - 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端
    - 字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输
- TCP 单机的最大连接数
    - 最大连接数=客户端IP数(2的32次方)*客户端端口数(2的16次方)
    - 实际上不能达到这个数量，主要是文件描述符(每个连接都要打开一个socket文件描述符)，系统默认是1024

- TCP 三次握手四次挥手

    - 3次握手
    ![innodb](https://github.com/caesar-empereur/read-book/blob/master/photo/tcp握手.png)
    
    - 三次握手过程中可以携带数据吗？
        - 第三次握手是可以携带数据的，而前两次不行
    - 为什么不是4次握手？
        - 4次相当于 客户端发送一次，等待回复确认，服务端发送一次，等待回复确认
                ```
                1  SYNC  -->
                2  ACK   <--
                3  SYNC  <--
                4  ACK   -->
                
                2， 3 步 是可以合并成一次发送的
                ``` 
    - **[为什么是3次，不是2次握手?](#)**
        - **[避免历史连接造成的混乱](#)**
            - 网络环境是复杂的，不是先发就先到达，先发的可能后到达
            - 每次建立连接发送的 SYNC,ACK报文都是带有序列号的，用来判断上下文(因为多次交互)确定是否为历史连接
            - **[客户端才会判断上下文，服务端是不知道一个发过来的SYN是不是历史连接的](#)**
            ![tcp握手历史连接](https://github.com/caesar-empereur/read-book/blob/master/photo//tcp/tcp握手历史连接.png)

            ```
            客户端第一次发送 SYNC, 序号是90，很久也没收到回复，可能是服务端收到了，但回复报文拥堵了
            客户端发现刚发的 SYNC 过期没收到，再次发送 SYNC, 序号是91
            服务端对2个 SYNC 报文都收到并且回复了，但是90的 SYNC+ACK 回复报文先到客户端
            客户端这时候起到的是91的报文回复，发现是 90，于是发起 RST报文中止了连接
            客户端收到了 91的报文回复，确认是当前的连接，于是 发送 91 的ACK报文确定建立连接
            如果没有第三次的 91 ACK报文，服务端是不知道当前建立的连接是哪一个的
            ```
        - **[避免多余连接的建立](#)**
            - 如果只有2次握手，客户端发送完之后，服务端收到后的回复不确定客户端是否被收到
            - 这时服务端建立连接对客户端来说可能是历史连接，也就是无效连接，是浪费资源的
            - 客户端每一次开始发送的 SYN报文都阻塞了，于是多发了很多次，服务端收到后会建立多次无效连接
    - **[第三次握手失败了怎么办？](#)**
        - 握手的最后一个ACK发出去丢失了，服务端没收到会重发 SYNACK包指定次数，超过时间后没收到回复关闭连接
        - 客户端以为连接建立了，服务端连接关闭了，只要客户端开始发送数据就会带有ACK包，服务端的连接还是能建立
    - 4次挥手
    ![tcp挥手](https://github.com/caesar-empereur/read-book/blob/master/photo//tcp/tcp4次挥手.png)
    - **[4次挥手的原因](#)**
        - 正常情况下客户端一次 FIN 对应服务端一次ACK,服务端一次FIN对应客户端一次ACK
        - 第二次和第三次按理说可以合并为一次，**[但是服务端为了留有足够的时间发剩余的数据，ACK跟FIN分开了](#)**
    - **[为什么要有 TIME_WAIT 状态？](#)**
        - 主动发起关闭连接的一方，才会有 TIME-WAIT 状态。
        - time_wait 是什么？
          ```
          主动关闭连接的一方，会在发送完最后一个 ACK 报文之后进入 time_wait 状态，
          并且持续 MSL的时间，大概是一分钟，才入真正关闭连接，在MSL期间，这个连接不能被释放或者重新分配
          ```
        - **[保证连接正确关闭](#)**
            - 主动关闭的一方最后的 ACK 发出去后丢失了之后就直接是 CLOSE, 被动方此时没有收到ACK一直是LAST_ACK状态
            - 主动方因为是CLOSE状态了，重新建立连接，刚刚的被动方连接没关闭，不能重新建立建立，于是客户端无法创建新连接
        - **[为使旧的数据包在网络中丢失](#)**
            ```
            假设主动关闭方发完最后一个 ACK 后，就是 CLOSED 状态，前面的传输的报文因为延迟还没到达，
            该连接被重新分配发送数据，旧数据跟新数据一起达到另一方，会导致数据错乱
            ```
    
    - **[为什么 TIME_WAIT 等待的时间是 2MSL？](#)**
        - MSL: 报文最大生存时间,它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
        - **[保证主动关闭方最后的ACK丢失后能触发被动方的重发FIN](#)**
        - 主动关闭方发完ACK后，该ACK报文到达被动方最大时间是MSL,被动方没收到数据重发FIN也是MSL
        - 也就是最后的ACK报文过去和重发的FIN一来一回刚好是 2MSL
    - time_wait 的弊端
        ```
        线上服务器如果有太多 连接处于 time_wait 的话，会导致无法建立新的连接
        ```
    - 怎样确定一个TCP连接？
        * 源IP, 源端口，目标IP，目标端口

- 浏览器建立关闭连接的过程
    
    * 浏览器打开一个页面的时候，可以看到浏览器会保持一个连接，状态是 ESTABLISHED
    * 用多个 tab 打开同一个网站，用的是同一个连接
    * 关闭一个网站之后，该TCP连接不会马上关闭，操作系统对该连接设置为 time_wait 状态
    * 在同一个网站的TCP连接还处于 time_wait 状态时再打开该网站，是会重新建立一个连接的，只是本地端口不一样

- linux 查看tcp状态的命令
    * netstat -an|grep tcp
    
- tcp 状态图

| 客户端的状态 | 服务端的状态 | 共有的状态 |
|:-----------:|:---------------:|--------:|
| SYNC_SENT | LISTEN | ETABLISHED |
| FIN_WAIT1 | SYN_RCVD | CLOSED |
| FIN_WAIT2 | CLOSE_WAIT |
| CLOSING | LAST_ACK |
| TIME_WAIT |  |


