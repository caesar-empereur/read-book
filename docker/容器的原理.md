## 操作系统容器的实现原理

- **[命名空间](#)**
    - 命名空间是Linux内核的一个强大特性, 可以实现 **[文件系统、网络， 进程之间的隔离](#)**
    
    - **[进程命名空间](#)**
        ```
        Linux通过进程命名空间管理进程号，对于同一进程，在不同的命名空间中，看到的进程号不相同
        ```
        - 进程命名空间是一个父子关系的结构，子空间中的进程对于父空间是可见的
        - 容器中的进程交互还是采用了Linux常见的进程间交互方法，包括信号量、消息队列和共享内存等方式
        - 不同空间的进程则无法交互
    - **[网络命名空间](#)**
![2pc](https://github.com/caesar-empereur/read-book/blob/master/photo/network-namespace.png)
        - 一个网络命名空间为进程提供了一个完全独立的网络协议栈的视图
        - Docker在宿主机上创建多个虚机网桥, 将不同命名空间容器的网络设备连接
        - 容器默认分配一个网桥上的虚拟网口，并将docker0的IP地址设置为默认的网关
        - 容器发起的网络流量通过宿主机的iptables规则进行转发
    - **[挂载命名空间](#)**
        - 挂载命名空间可以将一个进程的根文件系统限制到一个特定的目录
        - 挂载命名空间允许不同命名空间的进程看到的本地文件位于宿主机中不同路径下
        - 不同命名空间中的进程，都认为自己独占了一个完整的根文件系统
        - 实际上每个命名空间中的进程所看到的文件目录彼此是隔离的

- **[控制组](#)**
    - 目的是限制容器对宿主机的 系统资源使用，防止某个容器过度占用宿主机资源
    - 每个控制组都不能看到其他组的进程，文件系统，网络
- **[联合文件系统](#)**
![2pc](https://github.com/caesar-empereur/read-book/blob/master/photo/docker-file.png)
    - 一种轻量级的高性能分层文件系统, 同时可以将不同目录挂载到同一个虚拟文件系统下
    - 联合文件系统是实现Docker镜像的技术基础
    - Docker镜像可以通过联合文件系统的分层来进行继承
    - 对于基础镜像，每制作一次镜像，相当于给文件系统增加了一层，分发镜像的时候只需要分发改动的层即可
    - docker 利用镜像启动容器时，会在镜像文件系统的顶层进行读写，如果镜像操作发生在下层，需要复制到顶层
