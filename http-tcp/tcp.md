- TCP IP 分层模型
    ![tcp分层](https://github.com/caesar-empereur/read-book/blob/master/photo//tcp/tcp分层.png)
- TCP 是面向连接的、可靠的、**[基于字节流](#)**的传输层通信协议。
    - 面向连接：一定是「一对一」才能连接，发送数据之前需要建立点对点的连接
    - 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端
        - TCP 的可靠传输是怎么实现的？
            - **[TCP 是通过序列号、确认应答、重传机制、滑动窗口、流量控制、拥塞控制等机制实现可靠性传输的](#)**
    - 字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输
- TCP 单机的最大连接数
    - 最大连接数=客户端IP数(2的32次方)*客户端端口数(2的16次方)
    - 实际上不能达到这个数量，主要是文件描述符(每个连接都要打开一个socket文件描述符)，系统默认是1024

- TCP 三次握手四次挥手

    - 3次握手
    ![innodb](https://github.com/caesar-empereur/read-book/blob/master/photo/tcp握手.png)
    
    - 三次握手过程中可以携带数据吗？
        - 第三次握手是可以携带数据的，而前两次不行
    - 为什么不是4次握手？
        - 4次相当于 客户端发送一次，等待回复确认，服务端发送一次，等待回复确认
            ```
            1  SYNC  -->
            2  ACK   <--
            3  SYNC  <--
            4  ACK   -->
            
            2， 3 步 是可以合并成一次发送的
            ``` 
    - **[为什么是3次，不是2次握手?](#)**
        - **[避免历史连接造成的混乱](#)**
            - 网络环境是复杂的，不是先发就先到达，先发的可能后到达
            - 每次建立连接发送的 SYNC,ACK报文都是带有序列号的，用来判断上下文(因为多次交互)确定是否为历史连接
            - **[客户端才会判断上下文，服务端是不知道一个发过来的SYN是不是历史连接的](#)**
            ![tcp握手历史连接](https://github.com/caesar-empereur/read-book/blob/master/photo//tcp/tcp握手历史连接.png)

            ```
            客户端第一次发送 SYNC, 序号是90，很久也没收到回复，可能是服务端收到了，但回复报文拥堵了
            客户端发现刚发的 SYNC 过期没收到，再次发送 SYNC, 序号是91
            服务端对2个 SYNC 报文都收到并且回复了，但是90的 SYNC+ACK 回复报文先到客户端
            客户端这时候起到的是91的报文回复，发现是 90，于是发起 RST报文中止了连接
            客户端收到了 91的报文回复，确认是当前的连接，于是 发送 91 的ACK报文确定建立连接
            如果没有第三次的 91 ACK报文，服务端是不知道当前建立的连接是哪一个的
            ```
        - **[避免多余连接的建立](#)**
            - **[总结就是2次握手的话，服务端回复ACK之后不能保证被收到，建立的连接可能是无效连接](#)**
            - 如果只有2次握手，客户端发送完之后，服务端收到后的回复不确定客户端是否被收到
            - 这时服务端建立连接对客户端来说可能是历史连接，也就是无效连接，是浪费资源的
            - 客户端每一次开始发送的 SYN报文都阻塞了，于是多发了很多次，服务端收到后会建立多次无效连接
    - **[第三次握手失败了怎么办？](#)**
        - 握手的最后一个ACK发出去丢失了，服务端没收到会重发 SYNACK包指定次数，超过时间后没收到回复关闭连接
        - 客户端以为连接建立了，服务端连接关闭了，只要客户端开始发送数据就会带有ACK包，服务端的连接还是能建立
    - 4次挥手
    ![tcp挥手](https://github.com/caesar-empereur/read-book/blob/master/photo/tcp/tcp4次挥手.png)
    - **[4次挥手的原因](#)**
        - 正常情况下客户端一次 FIN 对应服务端一次ACK,服务端一次FIN对应客户端一次ACK
        - 第二次和第三次按理说可以合并为一次，**[但是服务端为了留有足够的时间发剩余的数据，ACK跟FIN分开了](#)**
    - **[为什么要有 TIME_WAIT 状态？](#)**
        - 主动发起关闭连接的一方，才会有 TIME-WAIT 状态。
        - time_wait 是什么？
          ```
          主动关闭连接的一方，会在发送完最后一个 ACK 报文之后进入 time_wait 状态，
          并且持续 MSL的时间，大概是一分钟，才入真正关闭连接，在MSL期间，这个连接不能被释放或者重新分配
          ```
        - **[保证连接正确关闭](#)**
            - **[总结就是：防止客户端发完最后ACK之后就是关闭状态，连接马上被重分配](#)**
            - 主动关闭的一方最后的 ACK 发出去后丢失了之后就直接是 CLOSE, 被动方此时没有收到ACK一直是LAST_ACK状态
            - 主动方因为是CLOSE状态了，重新建立连接，刚刚的被动方连接没关闭，不能重新建立建立，于是客户端无法创建新连接
        - **[为使旧的数据包在网络中丢失](#)**
            ```
            假设主动关闭方发完最后一个 ACK 后，就是 CLOSED 状态，前面的传输的报文因为延迟还没到达，
            该连接被重新分配发送数据，旧数据跟新数据一起达到另一方，会导致数据错乱
            ```
    
    - **[为什么 TIME_WAIT 等待的时间是 2MSL？](#)**
        - MSL: 报文最大生存时间,它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃
        - **[保证主动关闭方最后的ACK丢失后能触发被动方的重发FIN](#)**
        - 主动关闭方发完ACK后，该ACK报文到达被动方最大时间是MSL,被动方没收到数据重发FIN也是MSL
        - 也就是最后的ACK报文过去和重发的FIN一来一回刚好是 2MSL
    - time_wait 的弊端
        ```
        线上服务器如果有太多 连接处于 time_wait 的话，会导致无法建立新的连接
        ```
    - 怎样确定一个TCP连接？
        * 源IP, 源端口，目标IP，目标端口

- **[TCP 超时重传和快速重传机制](#)**
    - TCP 的可靠传输是怎么实现的？
        - **[TCP 是通过序列号、确认应答、重传机制、滑动窗口、流量控制、拥塞控制等机制实现可靠性传输的](#)**
    ![TCP可靠性保证](https://github.com/caesar-empereur/read-book/blob/master/photo/tcp/TCP可靠性保证.png)
    - 重传机制是TCP可靠性保证的一个基本因素
    - 超时重传
        - 重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后
        - 没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传
        - 超时重传机制发生在 数据包丢失，回复确认丢失的情况下
        - 超时重传的定时器时间是 一个报文在 2 端往往返的时间
        - 超时重传机制的弊端就是数据丢失需要等待一段时间才知道，不够及时

    - **[快速重传](#)**
        - 快速重传不以时间为驱动，而是以数据驱动重传
        ![TCP快速重传](https://github.com/caesar-empereur/read-book/blob/master/photo/tcp/TCP快速重传.png)
        ```
        发送方发了 1-5，接收方没收到 2 ，于是 345来的时候都是回复 2 的确认
        发送方连续收到3个 2的ACK，确认是 2 的数据包丢失，在超时时间还没到就已经重发2的报文
        接收方收到了2的数据包，数据包序号连续，于是发了5之后的6 ACK 包
        ```
        - **[总结就是，接收方收到的数据包的顺序如果缺少了一个，以后的回复ACK包都会用这个来累计重复次数](#)**
        - 快速重传只是解决了时间的问题(不用等到超时时间)，无法确定是重传丢失那个还是丢失之后的全部
        
- **[TCP滑动窗口](#)**
    - **[TCP 是每发送一个数据，都要进行一次确认应答，这种方式的缺点是效率比较低的](#)**
    - 数据包的往返时间越长，通信的效率就越低
    - **[引入窗口就是为了无需每次的发送等待应答，就可以继续发送数据](#)**
    - **[窗口实际上就是操作系统开辟的一个缓冲区，发送完的数据没收到确认就留在缓冲区，收到确认的可以删除](#)**
    - TCP 头里有一个字段叫 Window，也就是窗口大小
    ```
    这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据
    这个接收端的处理能力来发送数据，而不会导致接收端处理不过来
    ```
    - 发送1-5，2丢失了，也不会重发，只要后面有收到6的回复ACK，说明2又到达了，这时可以将1-5从缓冲区清空
    - 发送方一次性发送很多数据把缓冲区占满，窗口大小为0，没收到回复的ACK之前不能发数据
    - **[等到收到几个ACK后，可以将对应范围的数据从缓冲区清空，相当于缓冲区又移动，这就是滑动窗口](#)**
- **[TCP拥塞控制](#)**
    - **[流量控制是为了避免发送方发送的数据填满接收方的缓冲区](#)**
    ```
    在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，
    但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，
    这个情况就会进入恶性循环被不断地放大....
    ```
    - **[拥塞控制是为了发送发为了避免网络的数据拥堵而自我调节的一种机制](#)**
    - 发送方为了调节发送的数据量，维护了一个拥塞窗口的缓冲区，类似滑动窗口，通过这个窗口来调节发送数据量
    - 拥塞控制的4种算法
        - **[慢启动](#)**
            - 连接建立之后逐步提高发送数据量，每收到一个ACK，拥塞窗口n就加1，来提高发送数据量，直到超过拥塞窗口阈值
        - **[拥塞避免](#)**
            - 慢启动超过阈值之后，每收到一个ACK，拥塞窗口n 就加 1/n，来提高发送数据量
        - 拥塞发生
        - 快速恢复
    
- TCP粘包问题
    - TCP 位于传输层，保证的是数据的可靠性(顺序发送，重传机制，流量控制，拥塞控制)
    - 传输层的数据格式是字节流，字节流是没有边界的，没边界数据就会粘在一起，就是粘包
    - TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾
    - 粘包的解决？
        - 传输的数据加上边界表示，例如换行或者其他特殊字符
        - 应用层发送数据时消息定长发送
    
- 浏览器建立关闭连接的过程
    
    * 浏览器打开一个页面的时候，可以看到浏览器会保持一个连接，状态是 ESTABLISHED
    * 用多个 tab 打开同一个网站，用的是同一个连接
    * 关闭一个网站之后，该TCP连接不会马上关闭，操作系统对该连接设置为 time_wait 状态
    * 在同一个网站的TCP连接还处于 time_wait 状态时再打开该网站，是会重新建立一个连接的，只是本地端口不一样

- linux 查看tcp状态的命令
    - netstat -an|grep tcp
    - netstat -ant|awk '/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}'
    ```
    LISTEN 27
    TIME_WAIT 20
    ESTABLISHED 216
    ```
    
- **[linux 服务器大量的TIME_WAIT状态的排查处理](#)**
    - 主动关闭连接的一方，会在发送完最后一个 ACK 报文之后进入 time_wait 状态, 处于该状态的连接不能重新分配
    - 在高并发的服务器上，当服务器处理完请求后并不会马上关闭连接，这个场景下会出现大量socket处于TIME_WAIT状态
    - 如果线上服务出现 time_wait 过多，会导致新的请求无法处理
    - 紧急处理办法：打开系统的 TIMEWAIT 重置和快速回收
    ```
    vi /etc/sysctl.conf
    
    net.ipv4.tcp_tw_reuse = 1
    net.ipv4.tcp_tw_recycle = 1
    net.ipv4.tcp_timestamps = 1
    net.ipv4.tcp_fin_timeout = 20
    
    sysctl -p 生效
    ```
    
- tcp 状态图

| 客户端的状态 | 服务端的状态 | 共有的状态 |
|:-----------:|:---------------:|--------:|
| SYNC_SENT | LISTEN | ETABLISHED |
| FIN_WAIT1 | SYN_RCVD | CLOSED |
| FIN_WAIT2 | CLOSE_WAIT |
| CLOSING | LAST_ACK |
| TIME_WAIT |  |


