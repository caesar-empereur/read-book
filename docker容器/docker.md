## docker 背景

- 传统的部署方式，服务器迁移，需要对应用环境重新安装配置，相当繁琐
- 不同的服务对运行库版本等环境的依赖不一样，传统的方式就要用多台机器
- 在云时代，开发者创建的应用必须要能很方便地在网络上传播，脱离底层物理硬件的限制
- 运行Docker容器不需要额外的虚拟化管理程序，Docker是内核级的虚拟化
- docker 的容器相当于应用沙箱，各个容器的运行环境是隔离的
- docker 属于操作系统虚拟化，虚拟机属于硬件虚拟化
- linux 的容器技术是由内核支持的，通过控制组隔离，并把应用和运行库打包在一起，来实现这个目的
- windos 的容器技术是通过Hyper-V运行不同的虚拟机进行内核级隔离——线程级的隔离
- 容器的短生命周期和增加的部署密度使得基础设施监控愈加重要

## docker 镜像，容器，仓库的关系

| 概念  | 解释  |
|:---------------|:-------------------|
|镜像 | 就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统 |
|容器 | 镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 |
|仓库 | 仓库可看成一个代码控制中心，用来保存镜像 |

```
镜像类似 类，容器类似类创建的实例对象，仓库类似代码存放的地方
```

## docker 适合部署什么
- docker 容器技术针对的适合水平伸缩，能用于无状态计算的服务
- Docker 快速扩展的一个重要特征就是无状态，具有数据状态的都不适合直接放在 Docker 里面
```
刚开始的时候，Docker一般只适用于无状态的计算场景使用。但随着发展，Docker通过data volume技术
也可以做到数据持久化了。Data volume就是我们将主机的某个目录挂载到容器里面，
这个data volume不受storage driver的控制，所有对这个data volume的操作
会绕过storage driver直接其操作，其性能也只受本地主机的限制。而且我们
可以挂载任意多个data volume到容器中，不同容器也可以共享同一个data volume
```
- 有状态的服务对运行环境有高要求，例如 mysql IO访问，存储引擎对环境要求高，redis 需要内存容量大
- mysql 为啥不适合部署在 docker 中？

| 问题  | 原因  |
|:---------------|:-------------------|
|数据安全问题 | 容器随时可以停止、或者删除。当容器被rm掉，容器里的数据将会丢失 |
| | 为了避免数据丢失，用户可以使用数据卷挂载来存储数据。但是容器的 Volumes 设计是围绕 Union FS 镜像层提供持久存储，数据安全缺乏保证 |
|性能问题 | mysql IO访问，存储引擎对环境要求高 |
| | 数据库程序与数据分离, 数据库程序与数据需要进行分离，将数据存放到共享存储，程序放到容器里 |
| | 跑轻量级或分布式数据库 |
| 资源隔离| 如果其他应用过渡占用物理机资源，将会影响容器里 MySQL 的读写效率。 |

## docker 常见命令

| 指令  | 作用  |
|:---------------|:-------------------|
|docker search mysql | 搜索镜像 |
|docker pull mysql | 拉取镜像 |
|docker run -p 8189:8189 -d 镜像id| 启动镜像为运行的容器 |
|docker run -it ubuntu /bin/bash | 使用命令行运行容器 |
|docker images | 查看安装的镜像 |
|docker ps -a | 查看所有的运行的容器 |
|docker start 容器id | 启动容器 |
|docker stop  容器id | 停止容器 |
|docker rm 容器id | 删除容器 |
|docker logs 容器id (-f 可以实时输出)| 查看一个容器输出的错误日志 |
|docker inspect 容器id | 查看一个容器的 网络配置,容器本身的ip是多少 |
|docker exec -it 容器id /bin/bash | 进入容器命令，可以执行jvm之类的命令,相当于shell |

```
docker ps -a 是查看所有的容器，包括非运行状态的
docker ps | grep *** 可以用管道命令输出过滤
docker images | grep *** 可以用管道命令输出过滤
```

## Dockerfile

```
FROM java:8
ADD vue-admin-server.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
```

| 指令  | 作用  |
|:---------------|:-------------------|
|FROM | 定制的镜像都是基于 FROM 的镜像 |
|ADD | 把当前路径的文件添加到容器中 |
|EXPOSE | 暴露容器的指定端口 |
|ENTRYPOINT | 容器实际运行的命令 |
|docker build -t 镜像名称 . | 构建镜像 |
|docker images | 查看是否已经构建成功 |
|docker run -d -p 8080:8085 镜像名称 | 指定端口映射的方式来启动容器 |
|docker run --net=host 镜像名称 | 使用与宿主机一样的网络来启动容器 |


## docker 容器与宿主机的网络
- Docker提供几种网络类型，常见的有 bridge，host
    - bridge
    ```
    Bridge是Docker默认使用的网络类型。如图，网络中的所有容器可以通过IP互相访问。
    Bridge网络通过网络接口docker0 与主机桥接，容器中的网络与主机中的网络是隔离的
    可以在主机上通过ifconfig docker0查看到该网络接口的信息
    ```
    - host
    ```
    Host模式下，容器的网络接口不与宿主机网络隔离。容器与宿主机使用相同的网络，
    在容器中监听相应端口的应用能够直接被从宿主机访问。host网络仅支持Linux
    ```

## docker compose

```
Docker-Compose 是用来管理你的容器的，有点像一个容器的管家，想象一下当你
的Docker中有成百上千的容器需要启动，如果一个一个的启动那得多费时间


Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 
文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务
```
- 当有多个容器需要批量管理(启动，停止)时，compose 工具可以使用一个文件，
    配置好对应的容器，一个命令批量操作
- Compose 使用的三个步骤：
    - 使用 Dockerfile 定义应用程序的环境。
    - 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。
    - 最后，执行 docker-compose up 命令来启动并运行整个应用程序。
- 启动的各个容器之间可以设置依赖关系，先启动A再启动B
- compose 支持的几个操作
    - 健康检查
    - 网络模式指定
    - 日志输出
- compose 核心理念就是批量管理一个机器上的多个隔离的容器，也只能在 **[单机]()** 上运行
- compose 也是容器编排技术的一种，**[属于单机版的声明式容器编排]()**

## 容器编排
```
在现代开发当中，整体式的应用早已成为过去时，如今的应用由数十乃至数百个松散结合的容器式组件构成，
而这些组件需要通过相互间的协同合作，才能使既定的应用按照设计运作。

容器编排是指对单独组件和应用层的工作进行组织的流程
```
- 对多个容器进行有计划的组织规划，包括指定好部署计划，对资源统一调度，当运行不满足计划时能有自行调节的功能
