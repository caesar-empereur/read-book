- 线上服务器CPU%的排查方法
    - 用 **[top](#)** 命令找出占用CPU的进程
    - **[top -Hp PID](#)** 找出该进程下面的多个线程的CPU占用情况
        ```
        root@leon:~# top -Hp 10263
        
        top - 15:56:00 up 31 days,  7:55,  1 user,  load average: 0.52, 1.02, 1.16
        Threads:  40 total,   0 running,  40 sleeping,   0 stopped,   0 zombie
        %Cpu(s):  2.8 us,  4.3 sy,  0.0 ni, 74.0 id, 18.8 wa,  0.0 hi,  0.1 si,  0.0 st
        KiB Mem :  3847484 total,   108724 free,  3552008 used,   186752 buff/cache
        KiB Swap:        0 total,        0 free,        0 used.    78048 avail Mem
        
        10263 root      20   0 2675324 300524      0 S  0.0  7.8   0:00.00 java
        10264 root      20   0 2675324 300524      0 S  0.0  7.8   0:05.41 java
        10265 root      20   0 2675324 300524      0 S  0.0  7.8   0:00.92 java
        10266 root      20   0 2675324 300524      0 S  0.0  7.8   0:00.96 java
        ```
    - 上面命令输出的占用高的线程id是10进制的，需要转换成 16 进制， **[printf "%0x\n" 线程id](#)**
        ```
        root@leon:~# printf "%0x\n" 10263
        2817
        ```
    - jstack pid >/home/thread.log 转储到文件
    - 在这个 thread.log 找到16进制的线程，找到对应的类跟方法调用
        ```
        "http-nio-8081-AsyncTimeout" #32 daemon prio=5 os_prio=0 tid=0x00007f3b6994a800 nid=0x287b waiting on condition [0x00007f3b1a3ee000]
           java.lang.Thread.State: TIMED_WAITING (sleeping)
        	at java.lang.Thread.sleep(Native Method)
        	at org.apache.coyote.AbstractProtocol$AsyncTimeout.run(AbstractProtocol.java:1211)
        	at java.lang.Thread.run(Thread.java:748)
        ```
