- List
    - 集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。

- ArrayList
    - 基于动态数组的实现，它长于随机访问元素，但是在中间插入和移除元素时较慢，它允许任何符合规则的元素插入甚至包括null

- LinkedList
```
基于链表实现，在List中间进行插入和删除的代价较低，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢
在JAVA中，LinkedList可以作为我们最经常使用的两种数据结构来使用：栈和队列。Java中实现队列一般都是用LinkedList实现。
这是因为LinkedList的实现是一个双向链表，所以无论是FIFO还是FILO都可以实现。

Linkedlist特有的方法：
addFirst(E e) 
addLast(E e) 
getFirst() 
getLast() 
removeFirst() 
removeLast() 

：栈   : 主要是用于实现堆栈数据结构的存储方式。
push() 
pop()

：队列（双端队列1.5）： 主要是为了让你们可以使用LinkedList模拟队列数据结构的存储方式。
offer()
poll()

```

- Set 元素不能重复
    - HashSet 是用HashMap实现的
```
private transient HashMap<E,Object> map;
private static final Object PRESENT = new Object();
public HashSet() {
    map = new HashMap<>();
}
//添加元素用 map.put 方法，去重是利用HashMap的 key 不能相同的原理,
map的put 操作需要用到 对象的 hashCode 与 equals() 方法来保持 key 的唯一性
public boolean add(E e) {
    return map.put(e, PRESENT)==null;	//PRESENT一直是同一个对象
}
public boolean remove(Object o) {
    return map.remove(o)==PRESENT;
}
public void clear() {
    map.clear();
}
```

- TreeSet 
    - 实现了SortedSet接口,是有序的,依赖于TreeMap，它实际上是通过TreeMap实现的。
```
提供了集合元素的顺序存储,其中元素保持升序排列.为了在加入一个元素到SortedSet实现时能对这些元素排序,
元素类型必须实现Comarable接口,或者建立SortedSet时使用Comparator.否则程序在运行时将抛出ClassCastException.
```

- Map
```
与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。
在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同
```

- HashMap
    - 不保证插入的顺序,就是访问的顺序与插入的顺序可能不相同

- LinkedHashMap
    - LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。

- TreeMap
    - 是一个有序的key-value集合，非同步，基于红黑树实现，TreeMap存储时会进行排序的，
    - 会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序
    
```
自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。
定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，
采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。
TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。
如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，
TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0
```


```
public class TreeMap<K,V>  extends AbstractMap<K,V>  implements SortedMap<K,V>
//TreeMap 是根据红黑树实现的有序的map，有序是指key是按照自然排序的（字母排序，自然数排序）
private final Comparator<? super K> comparator;
private transient Entry<K,V> root;

public V get(Object key) {
       Comparable<? super K> k = (Comparable<? super K>) key;
Entry<K,V> p = root;
while (p != null) {
//根据比较器不断比较 key，直到找到红黑树上 与该 key 相等的节点，返回对应的值
    	int cmp = k.compareTo(p.key);
 cmp < 0 ? p = p.left : p = p.right;
    	else  return p.value;
 }
}

public V put(K key, V value) {
    Entry<K,V> t = root;
   //根节点为空，新加入的节点作为根节点，然后返回
    int cmp;
    Entry<K,V> parent;
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
    // 根据比较器的compare()方法在红黑树上根据顺序一直找到插入的子节点
            cmp = cpr.compare(key, t.key);
     t = cmp<0 ? t.left : t.right;
            else  return t.setValue(value);
        } while (t != null);
    }
    Entry<K,V> e = new Entry<>(key, value, parent);
   //找到插入位置的父节点，判断应该插入左子节点还是又子节点
    cmp < 0 ? parent.left = e : parent.right = e;
    fixAfterInsertion(e); //红黑树插入一个节点后需要变色翻转
    size++; modCount++;
    return null;
}
```

- HashMap

![HashMap](https://github.com/caesar-empereur/read-book/blob/master/photo/HashMap.png)
