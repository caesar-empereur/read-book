- List
    - 集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。

- ArrayList
    - 基于动态数组的实现，它长于随机访问元素，但是在中间插入和移除元素时较慢，它允许任何符合规则的元素插入甚至包括null
    ```
    public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, 
                                                    Cloneable, java.io.Serializable{
                                                    
        transient Object[] elementData;
        private int size;
        public ArrayList(int initialCapacity) {
            this.elementData = new Object[initialCapacity];
        }
        
        public boolean add(E e) {
            ensureCapacityInternal(size + 1);
            elementData[size++] = e;
            return true;
        }
        
        public E remove(int index) {
            rangeCheck(index);
            modCount++;
            E oldValue = elementData(index);
            int numMoved = size - index - 1;
            if (numMoved > 0)
                System.arraycopy(elementData, index+1, elementData, index,numMoved);
            elementData[--size] = null; // clear to let GC do its work
            return oldValue;
        }
        
        public E get(int index) {
            rangeCheck(index);
            return elementData(index);
        }
        
        private E elementData(int index) {
            return (E) elementData[index];
        }
    }
    ```
- LinkedList
    - 基于链表实现，在List中间进行插入和删除的代价较低
    - 提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢
    - **[可以作为队列使用, addFirst(), getLast()](#)**
    - **[也可以作为栈结构来使用, addFirst(), removeFirst()](#)**
```
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, 
                                    Deque<E>, Cloneable, java.io.Serializable{
     transient int size = 0;
     transient Node<E> first;
     transient Node<E> last;
     
    public E getFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return f.item;
    }
    
    public E getLast() {
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return l.item;
    }
    
    public E removeFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }
    
    public E removeLast() {
        final Node<E> l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    }
    
    public void addFirst(E e) {
        linkFirst(e);
    }
    
    private void linkFirst(E e) {
        final Node<E> f = first;
        final Node<E> newNode = new Node<>(null, e, f);
        first = newNode;
        if (f == null)
            last = newNode;
        else
            f.prev = newNode;
        size++;
        modCount++;
    }
    
    public void addLast(E e) {
        linkLast(e);
    }
    
    public boolean add(E e) {
        linkLast(e);
        return true;
    }
    
    private void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }
    
    public E get(int index) {
        checkElementIndex(index);
        return node(index).item;
    }
    
    private Node<E> node(int index) {
        if (index < (size >> 1)) {
            Node<E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }
}

```

- Set 元素不能重复
    - HashSet 是用HashMap实现的
    ```
    public class HashSet<E> extends AbstractSet<E> implements Set<E>, 
                                    Cloneable, java.io.Serializable{
                                    
        private transient HashMap<E,Object> map;
        
        private static final Object PRESENT = new Object();
        
        public HashSet() {
            map = new HashMap<>();
        }
        /*
        添加元素用 map.put 方法，去重是利用HashMap的 key 不能相同的原理,
        map的put 操作需要用到 对象的 hashCode 与 equals() 方法来保持 key 的唯一性
        */
        public boolean add(E e) {
            return map.put(e, PRESENT)==null;	//PRESENT一直是同一个对象
        }
        public boolean remove(Object o) {
            return map.remove(o)==PRESENT;
        }
        public void clear() {
            map.clear();
        }
    }
    
    ```

- HashMap
    - 不保证插入的顺序,就是访问的顺序与插入的顺序可能不相同
    ![HashMap](https://github.com/caesar-empereur/read-book/blob/master/photo/HashMap.png)


- LinkedHashMap
    - LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。

- TreeMap
    - 是一个有序的key-value集合，非同步，基于红黑树排序实现，TreeMap存储时会进行排序的，
    - 会根据key来对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序
        - **[自然排序](#)**
            - key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常
        - **[定制排序](#)**
            - TreeMap 构造方法中传入一个comparator对象，该对象对所有的treeMap中所有的key值进行排序
        - 默认是根据 key 实现的Comparable接口来排序的，不是根据 Comparator 外部排序
        - **[如果 key 没有实现Comparable接口, 构造方法也没有传入 Comparator 排序类，put 的时候会报错的](#)**
    
    ```
    public class TreeMap<K,V>  extends AbstractMap<K,V>  implements SortedMap<K,V>
    
        //TreeMap 是根据红黑树实现的有序的map，有序是指key是按照自然排序的（字母排序，自然数排序）
        
        private final Comparator<? super K> comparator;
        private transient Entry<K,V> root;
        
        public TreeMap() {
            /**
            默认是 不 使用这个比较器来进行排序的
            是按照 key 实现的Comparable接口来排序的
            */
            comparator = null;
        }
        
        public V get(Object key) {
            Entry<K,V> p = getEntry(key);
            return (p==null ? null : p.value);
        }
        
        public V get(Object key) {
            Comparable<? super K> key = (Comparable<? super K>) key;
            Entry<K,V> p = root;
            while (p != null) {
                 //根据比较器不断比较 key，直到找到红黑树上 与该 key 相等的节点，返回对应的值
                 int cmp = key.compareTo(p.key);
                 if (cmp < 0) {
                    p = p.left;
                 } else if (cmp > 0){
                    p = p.right;
                 }
                 else {
                    return p;
                 }
             }
        }
    
        public V put(K key, V value) {
            Entry<K,V> t = root;
            //根节点为空，新加入的节点作为根节点，然后返回
            int cmp;
            Entry<K,V> parent;
            Comparator<? super K> cpr = comparator;
            if (cpr != null) {
                do {
                    parent = t;
                    cmp = cpr.compare(key, t.key);
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else
                        return t.setValue(value);
                } while (t != null);
            } else {
                if (key == null) {
                    throw new NullPointerException();
                    Comparable<? super K> k = (Comparable<? super K>) key;
                }
                do {
                    parent = t;
                    cmp = k.compareTo(t.key);
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else
                        return t.setValue(value);
                } while (t != null);
            }
            Entry<K,V> e = new Entry<>(key, value, parent);
            //找到插入位置的父节点，判断应该插入左子节点还是又子节点
            if (cmp < 0) {
                parent.left = e;
            } else {
                parent.right = e;
            }
             //红黑树插入一个节点后需要变色翻转
            fixAfterInsertion(e);
            size++;
            modCount++;
            return null;
        }
        
        /**
        取出红黑树的第一个 key，因为红黑树的节点都是按照 key 排序的
        因此第一个key是红黑树的最左边的叶子节点，按照排序，这个节点应该是最小的
        */
        public K firstKey() {
            return key(getFirstEntry());
        }
        
        private Entry<K,V> getFirstEntry() {
            Entry<K,V> p = root;
            if (p != null)
                while (p.left != null)
                    p = p.left;
            return p;
        }
        
        /**
        取出红黑树的 最后一个 key，因为红黑树的节点都是按照 key 排序的
        因此最后一个key是红黑树的最右边的叶子节点，按照排序，这个节点应该是最大的
        */
        public K lastKey() {
            return key(getLastEntry());
        }
        
        private Entry<K,V> getLastEntry() {
            Entry<K,V> p = root;
            if (p != null)
                while (p.right != null)
                    p = p.right;
            return p;
        }
        
        /**
        取出比指定的key小的所有key中最大的一个
        */
        public K lowerKey(K key) {
            return keyOrNull(getLowerEntry(key));
        }
        
        /**
        取出比指定的key大的所有key中最小的一个
        */
        public K higherKey(K key) {
            return keyOrNull(getHigherEntry(key));
        }
    }
    ```
    
- TreeSet 
    - 实现了SortedSet接口,是有序的,依赖于TreeMap，它实际上是通过TreeMap实现的。
    ```
    提供了集合元素的顺序存储,其中元素保持升序排列.为了在加入一个元素到SortedSet实现时能对这些元素排序,
    元素类型必须实现Comarable接口,或者建立SortedSet时使用Comparator.否则程序在运行时将抛出ClassCastException.
    ```
    ```
    public class TreeSet<E> extends AbstractSet<E> implements NavigableSet<E>, 
                                            Cloneable, java.io.Serializable {
                                            
        private transient TreeMap<E,Object> treeMap;
        private static final Object PRESENT = new Object();
        
        public TreeSet() {
            this.treeMap = new TreeMap<E,Object>();
        }
        
        public boolean add(E e) {
            return treeMap.put(e, PRESENT)==null;
        }
        
        public boolean remove(Object o) {
            return treeMap.remove(o)==PRESENT;
        }
        
        /**
        treeMap 红黑树的节点是按照节点的key排序的，treeSet 存储的就是红黑树的所有排序的节点的 key
        这里是取出红黑树 的排序的节点中 最左边的叶子节点
        */
        public E first() {
        
            /**
            treeMap.firstKey() 方法的含义
            
            取出红黑树的第一个 key，因为红黑树的节点都是按照 key 排序的
            因此第一个key是红黑树的最左边的叶子节点，按照排序，这个节点应该是最小的
            */
            return treeMap.firstKey();
        }
        
        /**
        treeMap 红黑树的节点是按照节点的key排序的，treeSet 存储的就是红黑树的所有排序的节点的 key
        这里是取出红黑树 的排序的节点中 最右边的叶子节点
        */
        public E last() {
            /**
            取出红黑树的 最后一个 key，因为红黑树的节点都是按照 key 排序的
            因此最后一个key是红黑树的最右边的叶子节点，按照排序，这个节点应该是最大的
            */
            return treeMap.lastKey();
        }
        
        // 拿出并且移除第一个元素
        public E pollFirst() {
            Map.Entry<E,?> e = treeMap.pollFirstEntry();
            return (e == null) ? null : e.getKey();
        }
        
        // 拿出并且移除最后一个元素
        public E pollLast() {
            Map.Entry<E,?> e = treeMap.pollLastEntry();
            return (e == null) ? null : e.getKey();
        }
    }
    ```

- LinkedHashMap
    - 继承自 HashMap 的结构，Entry 节点使用了前后2个指针来实现双向队列
    - HashMap 是在数组的同一个下标的多个节点才会形成链表
    - LinkedHashMap 是在数组不同下标的节点之间也会形成链表，就是所有节点维护成一个无序链表
    - **[访问排序](#)**
        - LinkedHashMap 的一个重要特性就是是否需要访问排序，一个 key 被访问后会移动到链表的末端
        - 在链表的头就是访问次数最少的key，末端就是最近访问的key
        - 添加元素的时候如果容量满了，根据实现的是否删除最老的 key 的接口，执行删除key的策略
    
    - **[LinkedHashMap 实现 LRU](#)**（最近使用次数少的内存淘汰策略）
    ```
    public class SimpleLRUCache extends LinkedHashMap<K, V>{
        public void setCacheLimit(int cacheLimit) {
            this.cacheLimit = cacheLimit;
        }
        
        @Override
        protected boolean removeEldestEntry(Map.Entry<Resource, MetadataReader> eldest) {
            return super.size() > this.cacheLimit;
        }
    }
    ```
    
```
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>{

    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
    
    transient LinkedHashMap.Entry<K,V> head;
    transient LinkedHashMap.Entry<K,V> tail;
    
    /**
    是否是访问排序
    访问排序的意思是一个key只要被访问一次，就会移动到链表的
    尾部，链表尾部是最新访问的，头部是访问次数最少的
    
    不是访问排序的话，就会按照插入排序处理
    */
    final boolean accessOrder;
    
    public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }
    
    public V get(Object key) {
        Node<K,V> e;
        if ((e = getNode(hash(key), key)) == null) {
            return null;
        }
        if (accessOrder) {
            afterNodeAccess(e);
        }
        return e.value;
    }
    
    private void afterNodeInsertion(boolean evict) {
        // possibly remove eldest
        LinkedHashMap.Entry<K,V> first;
        if (evict && (first = head) != null && removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, null, false, true);
        }
    }
    
    private void afterNodeAccess(Node<K,V> e) { // move node to last
        LinkedHashMap.Entry<K,V> last;
        if (accessOrder && (last = tail) != e) {
            LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
            p.after = null;
            if (b == null)
                head = a;
            else
                b.after = a;
            if (a != null)
                a.before = b;
            else
                last = b;
            if (last == null)
                head = p;
            else {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }
}
```
